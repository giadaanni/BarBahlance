<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bar Bahlance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Press Start 2P', cursive; }
        #game-container { position: relative; width: 100vh; max-width: 100%; aspect-ratio: 2/3; background-color: #3d2e4d; overflow: hidden; border: 4px solid #000; }
        canvas { display: block; width: 100%; height: 100%; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; }
        #start-screen { background: url('./ASSET/BarBahlance_mainScreen.png') no-repeat center center; background-size: cover; pointer-events: auto; cursor: pointer; z-index: 20; }
        .blink-text { margin-top: 60%; color: #fff; text-shadow: 4px 4px 0 #000; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        #hud { display: none; justify-content: flex-start; padding-top: 20px; color: white; text-shadow: 2px 2px 0 #000; font-size: 14px; }
        #countdown { font-size: 40px; color: yellow; display: none; }
        #game-over-screen { background: rgba(0, 0, 0, 0.85); display: none; pointer-events: auto; z-index: 30; }
        .btn { background: #ffcc00; border: 4px solid #fff; padding: 15px 30px; font-family: 'Press Start 2P', cursive; cursor: pointer; margin-top: 20px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="start-screen" class="ui-layer" onclick="startGame()">
        <div class="blink-text">TAP TO START</div>
    </div>
    <div id="hud" class="ui-layer">
        <div id="level-display">LEVEL 1</div>
        <div id="items-display">Items: 0/3</div>
        <div id="countdown"></div>
    </div>
    <div id="game-over-screen" class="ui-layer">
        <h1 style="color: red; text-shadow: 3px 3px 0 #000;">CRASH!</h1>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Body, Constraint } = Matter;

    const LEVELS = [3, 5, 7, 10, 12];
    let engine, render, runner, tray, pivot;
    let items = [], currentLevelIdx = 0, spawnedCount = 0, isGameOver = false;
    const width = 600, height = 900;

    function init() {
        engine = Engine.create();
        engine.timing.timeScale = 0.9; // Rallenta leggermente per precisione

        const container = document.getElementById('game-container');
        render = Render.create({
            element: container,
            engine: engine,
            options: { width: width, height: height, wireframes: false, background: 'transparent' }
        });

        runner = Runner.create();
        render.canvas.addEventListener('mousemove', handleInput);
        render.canvas.addEventListener('touchmove', handleInput, {passive: false});

        Events.on(render, 'afterRender', () => { drawHand(); checkLoseCondition(); });
    }

    function setupLevel() {
        Composite.clear(engine.world);
        items = []; isGameOver = false;
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('level-display').innerText = `LEVEL ${currentLevelIdx + 1}`;
        
        // IL VASSOIO ORA Ãˆ DINAMICO (Reagisce ai pesi)
        tray = Bodies.rectangle(width / 2, height - 200, 360, 25, { 
            density: 0.01, friction: 0.3, frictionStatic: 0.3,
            render: { fillStyle: '#e0e0e0' }
        });

        // Perno centrale per permettere l'inclinazione fisica
        pivot = Constraint.create({
            pointA: { x: width / 2, y: height - 200 },
            bodyB: tray,
            stiffness: 1, length: 0,
            render: { visible: false }
        });

        Composite.add(engine.world, [tray, pivot]);
        Render.run(render);
        Runner.run(runner, engine);
        spawnedCount = 0;
        startSpawning();
    }

    function handleInput(e) {
        if (isGameOver || !tray) return;
        e.preventDefault();
        let clientX = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        const rect = render.canvas.getBoundingClientRect();
        const x = (clientX - rect.left) * (width / rect.width);

        // Controllo forza: il mouse inclina il vassoio attivamente
        const targetAngle = (x - width / 2) / (width / 2) * 1.2; 
        const angleDiff = targetAngle - tray.angle;
        
        // Applichiamo una forza di rotazione (torque) invece di settare l'angolo
        Body.setAngularVelocity(tray, angleDiff * 0.15);
        
        // Limite rotazione 140 gradi (circa 1.2 radianti per lato)
        if (Math.abs(tray.angle) > 1.2) {
            Body.setAngle(tray, 1.2 * Math.sign(tray.angle));
        }
    }

    function spawnItem() {
        const startX = (width / 2) + (Math.random() * 320 - 160); 
        const type = Math.floor(Math.random() * 5);
        let item;
        const props = { friction: 0.2, restitution: 0.1, density: 0.006 };

        switch(type) {
            case 0: // Boccale (Pesante)
                item = Body.create({ parts: [
                    Bodies.rectangle(startX, -50, 55, 75, { chamfer: 5, render: { fillStyle: '#f28e1c' }}),
                    Bodies.rectangle(startX + 32, -50, 15, 45, { chamfer: 10, render: { fillStyle: '#ddd' }})
                ], ...props, density: 0.008 });
                break;
            case 1: // Bottiglia (Alta, baricentro instabile)
                item = Body.create({ parts: [
                    Bodies.rectangle(startX, -50, 35, 70, { render: { fillStyle: '#2e8b57' }}),
                    Bodies.rectangle(startX, -95, 12, 40, { render: { fillStyle: '#1e5d3c' }})
                ], ...props });
                break;
            case 2: // Calice (Elegante e instabile)
                item = Body.create({ parts: [
                    Bodies.trapezoid(startX, -90, 50, 45, 0.6, { render: { fillStyle: '#900020' }}),
                    Bodies.rectangle(startX, -60, 6, 35, { render: { fillStyle: '#fff' }}),
                    Bodies.rectangle(startX, -45, 40, 6, { render: { fillStyle: '#fff' }})
                ], ...props, density: 0.005 });
                break;
            case 3: // Shot (Piccolo ma "piombato")
                item = Bodies.rectangle(startX, -50, 25, 35, { ...props, density: 0.01, render: { fillStyle: '#ADD8E6' }});
                break;
            case 4: // Drink (Standard)
                item = Bodies.rectangle(startX, -50, 50, 55, { ...props, render: { fillStyle: '#ff69b4' }});
                break;
        }
        items.push(item);
        Composite.add(engine.world, item);
    }

    function drawHand() {
        const ctx = render.context;
        ctx.beginPath();
        ctx.moveTo(width / 2, height); 
        ctx.lineTo(tray.position.x, tray.position.y); 
        ctx.lineWidth = 45; ctx.strokeStyle = '#e0ac69'; ctx.lineCap = 'round'; ctx.stroke();
    }

    function startSpawning() {
        let interval = setInterval(() => {
            if (isGameOver || spawnedCount >= LEVELS[currentLevelIdx]) { clearInterval(interval); if(!isGameOver) checkWinCountdown(); return; }
            spawnItem(); spawnedCount++;
            document.getElementById('items-display').innerText = `Items: ${spawnedCount}/${LEVELS[currentLevelIdx]}`;
        }, 2500);
    }

    function checkWinCountdown() {
        let sec = 8;
        const el = document.getElementById('countdown');
        el.style.display = 'block';
        let timer = setInterval(() => {
            if (isGameOver) { clearInterval(timer); return; }
            el.innerText = --sec;
            if (sec <= 0) { clearInterval(timer); currentLevelIdx++; setupLevel(); }
        }, 1000);
    }

    function checkLoseCondition() {
        if (isGameOver) return;
        items.forEach(item => { if (item.position.y > height + 50) gameOver(); });
    }

    function gameOver() { isGameOver = true; document.getElementById('game-over-screen').style.display = 'flex'; }
    function startGame() { document.getElementById('start-screen').style.display = 'none'; init(); setupLevel(); }
    function resetGame() { document.getElementById('game-over-screen').style.display = 'none'; currentLevelIdx = 0; setupLevel(); }
</script>
</body>
</html>
