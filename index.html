<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Bar Bahlance v83 debug</title>
  <style>
    :root{--bg:#0f1115;--panel:rgba(20,24,36,.92);--stroke:rgba(255,255,255,.12);--text:#e8e8e8;}
    html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #stage{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden;}
    canvas{display:block;touch-action:none;user-select:none;-webkit-user-select:none;border-radius:18px;background:#121625;}
    #hud{position:fixed;left:10px;right:10px;top:10px;display:flex;justify-content:space-between;gap:10px;z-index:5;pointer-events:none;}
    .pill{background:var(--panel);border:1px solid var(--stroke);border-radius:999px;padding:8px 12px;font-size:13px;backdrop-filter:blur(8px);display:flex;gap:10px;align-items:center;white-space:nowrap;}
    #debug{
      position:fixed;left:10px;right:10px;bottom:10px;z-index:9999;
      background:rgba(0,0,0,.65);border:1px solid rgba(255,255,255,.15);border-radius:12px;
      padding:10px;font-size:12px;line-height:1.35;white-space:pre-wrap;max-height:34vh;overflow:auto;
      pointer-events:none; /* IMPORTANT: non blocca i tocchi */
    }
    #debug b{color:#fff}
  </style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>

  <div id="hud">
    <div class="pill"><span>v83</span><span style="opacity:.6">•</span><span id="status">boot</span></div>
    <div class="pill"><span id="counts">bodies: -</span></div>
  </div>

  <div id="debug"><b>DEBUG</b>\n</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
  (() => {
    const dbg = document.getElementById('debug');
    const statusEl = document.getElementById('status');
    const countsEl = document.getElementById('counts');
    const log = (m)=>{ dbg.textContent += m + "\n"; };

    window.addEventListener('error', (e)=>log("JS ERROR: " + (e.message || e.error || "unknown")));
    window.addEventListener('unhandledrejection', (e)=>log("REJECTION: " + (e.reason?.message || e.reason)));

    log("Matter loaded? " + (!!window.Matter));
    if(!window.Matter){ statusEl.textContent="Matter FAIL"; return; }

    const { Engine, World, Bodies, Body, Composite } = Matter;

    // Canvas fit 2:3
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const WORLD_W=900, WORLD_H=1350;
    let cw=0,ch=0,dpr=1;

    function resize(){
      const w = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
      const h = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const targetH = Math.min(h, w*(3/2));
      const targetW = targetH*(2/3);
      cw = Math.floor(targetW); ch = Math.floor(targetH);
      canvas.style.width = cw+"px"; canvas.style.height = ch+"px";
      canvas.width = Math.floor(cw*dpr); canvas.height = Math.floor(ch*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      log(`resize: css=${cw}x${ch} dpr=${dpr} backing=${canvas.width}x${canvas.height}`);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    function worldToScreen(){
      const s = Math.min(cw/WORLD_W, ch/WORLD_H);
      const ox = (cw - WORLD_W*s)/2;
      const oy = (ch - WORLD_H*s)/2;
      return {s,ox,oy};
    }
    function w2s(x,y){
      const {s,ox,oy}=worldToScreen();
      return {x:ox + x*s, y:oy + y*s, s};
    }

    // Physics
    const engine = Engine.create({ enableSleeping:true });
    engine.gravity.y = 1.0;
    engine.positionIterations = 12;
    engine.velocityIterations = 10;

    const world = engine.world;

    World.add(world, [
      Bodies.rectangle(-110, WORLD_H/2, 220, WORLD_H+1000, {isStatic:true}),
      Bodies.rectangle(WORLD_W+110, WORLD_H/2, 220, WORLD_H+1000, {isStatic:true}),
      Bodies.rectangle(WORLD_W/2, WORLD_H+90, WORLD_W+1200, 180, {isStatic:true}),
    ]);

    const wrist = { x: WORLD_W*0.5, y: WORLD_H*0.68 };
    const trayHome = { x: wrist.x, y: wrist.y - 115 };

    const tray = Bodies.rectangle(trayHome.x, trayHome.y, 640, 36, {
      chamfer:{radius:14}, friction:1.2, label:"tray"
    });
    // Stabilizza: niente rotazioni “strane” dovute all’inerzia
    tray.inertia = Infinity;
    World.add(world, tray);

    // Input drag (su window per essere sicuri che i touch arrivino)
    let targetAngle=0, dragging=false, lastX=0;
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function getNormXFromClientX(clientX){
      const rect = canvas.getBoundingClientRect();
      return (clientX - rect.left) / rect.width;
    }

    function startDrag(clientX){
      dragging = true;
      lastX = getNormXFromClientX(clientX);
    }
    function moveDrag(clientX){
      if(!dragging) return;
      const x = getNormXFromClientX(clientX);
      const dx = x - lastX;
      lastX = x;
      targetAngle = clamp(targetAngle + dx*2.8, -0.62, +0.62);
    }
    function endDrag(){ dragging=false; }

    window.addEventListener('pointerdown', (e)=>startDrag(e.clientX), {passive:true});
    window.addEventListener('pointermove', (e)=>moveDrag(e.clientX), {passive:true});
    window.addEventListener('pointerup', endDrag, {passive:true});
    window.addEventListener('pointercancel', endDrag, {passive:true});

    window.addEventListener('touchstart', (e)=>startDrag(e.touches[0].clientX), {passive:true});
    window.addEventListener('touchmove', (e)=>moveDrag(e.touches[0].clientX), {passive:true});
    window.addEventListener('touchend', endDrag, {passive:true});

    // Loop
    let last=performance.now(), ticks=0;
    statusEl.textContent = "running";

    function drawBG(){
      const {s,ox,oy}=worldToScreen();
      ctx.save();
      ctx.translate(ox,oy);
      ctx.fillStyle="#121625";
      ctx.fillRect(0,0, WORLD_W*s, WORLD_H*s);
      ctx.restore();
    }

    function drawMarkers(){
      // wrist cross
      const p = w2s(wrist.x, wrist.y);
      ctx.save();
      ctx.strokeStyle="#ff4444";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(p.x-10, p.y); ctx.lineTo(p.x+10, p.y);
      ctx.moveTo(p.x, p.y-10); ctx.lineTo(p.x, p.y+10);
      ctx.stroke();
      ctx.restore();

      // tray marker
      const {s,ox,oy}=worldToScreen();
      ctx.save();
      ctx.translate(ox,oy);
      ctx.scale(s,s);
      ctx.translate(tray.position.x, tray.position.y);
      ctx.rotate(tray.angle);
      ctx.strokeStyle="#ffd45c";
      ctx.lineWidth=4;
      ctx.strokeRect(-320, -18, 640, 36);
      ctx.restore();
    }

    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last=now; ticks++;

      // KINEMATIC tray: posizione fissa + angolo imposto (NO sballa)
      const follow = 1 - Math.exp(-18*dt);
      const newAngle = tray.angle + (targetAngle - tray.angle)*follow;

      Body.setPosition(tray, trayHome);
      Body.setVelocity(tray, {x:0,y:0});
      Body.setAngle(tray, newAngle);
      Body.setAngularVelocity(tray, 0);

      Engine.update(engine, dt*1000);

      drawBG();
      drawMarkers();

      countsEl.textContent = "bodies: " + Composite.allBodies(world).length;

      if(ticks % 30 === 0){
        log(`tick=${ticks} target=${targetAngle.toFixed(3)} angle=${tray.angle.toFixed(3)} dragging=${dragging}`);
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>