<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BarBalance</title>
  <style>
    :root { --bg:#0f1115; --text:#e8e8e8; --muted:#aeb6c7; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;height:100%;}
    #stage{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden;}
    canvas{display:block;touch-action:none;-webkit-user-select:none;user-select:none;border-radius:18px;background:#121625;}
    #hud{
      position:fixed;
      left:max(10px, env(safe-area-inset-left));
      right:max(10px, env(safe-area-inset-right));
      top:max(10px, env(safe-area-inset-top));
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px;padding:8px 12px;font-size:13px;
      display:flex;gap:10px;align-items:center;white-space:nowrap;
      backdrop-filter: blur(8px);
    }
    button{pointer-events:auto;border:0;border-radius:999px;padding:8px 12px;background:#2b3350;color:#fff;font-weight:700;}
    button:active{transform:scale(.99)}
    #hint{
      position:fixed;left:50%;transform:translateX(-50%);
      bottom:max(12px, env(safe-area-inset-bottom));
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;padding:10px 12px;font-size:13px;color:var(--muted);
      pointer-events:none;
      max-width:min(520px, calc(100vw - 24px));
      text-align:center;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>

  <div id="hud">
    <div class="pill">
      <span id="score">Score: 0</span>
      <span style="opacity:.6">â€¢</span>
      <span id="items">Items: 0/10</span>
    </div>
    <div class="pill">
      <span id="state">OK</span>
      <button id="restart">Restart</button>
    </div>
  </div>

  <div id="hint">Trascina a sinistra/destra per ruotare il polso. Ogni oggetto che cade fuori = game over.</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
  (() => {
    const { Engine, World, Bodies, Body, Composite } = Matter;

    // ---- Canvas 2:3 fit (no scroll) ----
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function getViewport() {
      const h = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
      const w = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
      return { w, h };
    }

    const RATIO_W = 2, RATIO_H = 3;
    const WORLD_W = 900;
    const WORLD_H = 1350;

    let vw=0, vh=0, cw=0, ch=0, dpr=1;

    function resizeCanvas() {
      ({ w: vw, h: vh } = getViewport());
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const targetH = Math.min(vh, vw * (RATIO_H / RATIO_W));
      const targetW = targetH * (RATIO_W / RATIO_H);

      cw = Math.floor(targetW);
      ch = Math.floor(targetH);

      canvas.style.width = cw + "px";
      canvas.style.height = ch + "px";
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas, { passive:true });
    resizeCanvas();

    function worldToScreenScale() {
      return Math.min(cw / WORLD_W, ch / WORLD_H);
    }
    function worldToScreen(x, y) {
      const s = worldToScreenScale();
      const ox = (cw - WORLD_W * s) / 2;
      const oy = (ch - WORLD_H * s) / 2;
      return { x: ox + x * s, y: oy + y * s, s, ox, oy };
    }

    // ---- HUD ----
    const scoreEl = document.getElementById('score');
    const itemsEl = document.getElementById('items');
    const stateEl = document.getElementById('state');
    const restartBtn = document.getElementById('restart');
    const hintEl = document.getElementById('hint');

    function setState(s){ stateEl.textContent = s; }

    // ---- Physics ----
    const engine = Engine.create();
    engine.gravity.y = 1.0;
    const world = engine.world;

    // More stable solver
    engine.positionIterations = 10;
    engine.velocityIterations = 8;

    const wallThickness = 140;
    const walls = [
      Bodies.rectangle(WORLD_W/2, WORLD_H + wallThickness/2, WORLD_W + 600, wallThickness, { isStatic:true }),
      Bodies.rectangle(-wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 600, { isStatic:true }),
      Bodies.rectangle(WORLD_W + wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 600, { isStatic:true })
    ];
    World.add(world, walls);

    // Wrist + tray
    const wrist = { x: WORLD_W*0.5, y: WORLD_H*0.64 };

    const tray = Bodies.rectangle(wrist.x, wrist.y - 110, 640, 34, {
      restitution: 0.03,
      friction: 1.0,
      frictionStatic: 1.2,
      density: 0.0042,
      label: "tray"
    });
    World.add(world, [tray]);

    // Keep tray anchored (position fixed), only rotate
    function lockTrayPosition() {
      Body.setPosition(tray, { x: wrist.x, y: wrist.y - 110 });
      Body.setVelocity(tray, { x: 0, y: 0 });
    }

    // ---- Control (drag => target angle) ----
    let targetAngle = 0;
    const MAX_ANGLE = 0.42;     // slightly less extreme to stay fair
    const SENS = 2.0;
    let dragging = false;
    let lastX = 0;

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function getPointerX(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      return (clientX - rect.left) / rect.width;
    }
    function onDown(e){ dragging=true; lastX=getPointerX(e); hintEl.style.opacity = 0; }
    function onMove(e){
      if(!dragging) return;
      const x=getPointerX(e);
      const dx=x-lastX;
      lastX=x;
      targetAngle = clamp(targetAngle + dx*SENS, -MAX_ANGLE, +MAX_ANGLE);
    }
    function onUp(){ dragging=false; }

    canvas.addEventListener('pointerdown', (e)=>{ canvas.setPointerCapture(e.pointerId); onDown(e); }, { passive:true });
    canvas.addEventListener('pointermove', (e)=>onMove(e), { passive:true });
    canvas.addEventListener('pointerup', onUp, { passive:true });
    canvas.addEventListener('pointercancel', onUp, { passive:true });
    canvas.addEventListener('touchstart', onDown, { passive:true });
    canvas.addEventListener('touchmove', onMove, { passive:true });
    canvas.addEventListener('touchend', onUp, { passive:true });

    function controlTray(dt){
      // PD (smooth wrist feel)
      const kp=22.0, kd=6.0;
      const err = targetAngle - tray.angle;
      const dv = (kp*err - kd*tray.angularVelocity) * dt;
      Body.setAngularVelocity(tray, tray.angularVelocity + dv);

      // soft clamp
      if (Math.abs(tray.angle) > MAX_ANGLE*1.10) {
        Body.setAngle(tray, clamp(tray.angle, -MAX_ANGLE, +MAX_ANGLE));
        Body.setAngularVelocity(tray, tray.angularVelocity * 0.25);
      }
    }

    // ---- Items + fake liquids ----
    const MAX_ITEMS = 10;
    let alive=true, score=0, t=0;
    let nextSpawn=2.2;
    let spawnEvery=2.2;   // slower
    const droplets=[];

    function addDroplet(x,y,vx,vy,color){
      droplets.push({x,y,vx,vy,color,life:1.0});
    }

    function countItems(){
      const bodies = Composite.allBodies(world);
      let n=0;
      for (const b of bodies) {
        if (b.label==="tray" || b.isStatic) continue;
        n++;
      }
      return n;
    }

    function spawn(kind){
      // spawn across tray area, not only center
      const x = WORLD_W * (0.25 + Math.random()*0.50);
      const y = WORLD_H * 0.10;

      if (kind==="tumbler") {
        const b = Bodies.rectangle(x, y, 64, 92, {
          restitution: 0.02, friction: 0.95, density: 0.0032, label:"tumbler"
        });
        b.plugin = { liquid: { fill: 0.78, slosh: 0, color:"#6bdcff" } };
        World.add(world, b);
        return;
      }

      if (kind==="bottle") {
        // more iconic bottle (simple step shape) via vertices
        const verts = [
          {x:-25,y:-70},{x:25,y:-70},{x:25,y:40},{x:12,y:40},{x:12,y:70},
          {x:-12,y:70},{x:-12,y:40},{x:-25,y:40}
        ];
        const b = Bodies.fromVertices(x, y, [verts], {
          restitution: 0.02, friction: 0.7, density: 0.0038, label:"bottle"
        }, true);
        World.add(world, b);
        return;
      }

      if (kind==="wine") {
        const k = 1.35; // bigger goblet
        const verts = [
          {x:-10*k,y:-60*k},{x:10*k,y:-60*k},{x:26*k,y:-32*k},{x:18*k,y:0*k},
          {x:10*k,y:8*k},{x:10*k,y:44*k},{x:18*k,y:52*k},{x:18*k,y:62*k},
          {x:-18*k,y:62*k},{x:-18*k,y:52*k},{x:-10*k,y:44*k},{x:-10*k,y:8*k},
          {x:-18*k,y:0*k},{x:-26*k,y:-32*k}
        ];
        const b = Bodies.fromVertices(x, y, [verts], {
          restitution: 0.03, friction: 0.6, density: 0.0026, label:"wine"
        }, true);
        b.plugin = { liquid: { fill: 0.62, slosh: 0, color:"#ff7a59" } };
        World.add(world, b);
        return;
      }
    }

    function maybeSpawn(){
      if (!alive) return;
      if (countItems() >= MAX_ITEMS) return;         // cap 10
      if (t < nextSpawn) return;

      // slow, gently ramps (never becomes ridiculous)
      const difficulty = Math.min(1, t/90);
      spawnEvery = Math.max(1.25, spawnEvery * (0.992 - 0.003*difficulty)); // slows less over time
      nextSpawn = t + spawnEvery;

      const r = Math.random();
      if (r < 0.45) spawn("tumbler");
      else if (r < 0.78) spawn("wine");
      else spawn("bottle");
    }

    function updateLiquids(dt){
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (!b.plugin || !b.plugin.liquid) continue;
        const liq = b.plugin.liquid;

        const targetSlosh = clamp((-b.angularVelocity * 0.9) + (tray.angle * 0.7), -0.8, 0.8);
        liq.slosh += (targetSlosh - liq.slosh) * (1 - Math.exp(-8 * dt));

        const spillThresh = 0.55 - (liq.fill * 0.18);
        if (Math.abs(liq.slosh) > spillThresh && liq.fill > 0.08) {
          const spillRate = (Math.abs(liq.slosh) - spillThresh) * 0.18;
          liq.fill = Math.max(0, liq.fill - spillRate * dt);

          if (Math.random() < 0.22) {
            const p = b.position;
            addDroplet(p.x + (Math.random()*18-9), p.y - 55, (Math.random()*50-25), 50 + Math.random()*70, liq.color);
          }
        }
      }

      for (let i=droplets.length-1;i>=0;i--){
        const d = droplets[i];
        d.vy += 240 * dt;
        d.x += d.vx * dt;
        d.y += d.vy * dt;
        d.life -= dt;
        if (d.life <= 0 || d.y > WORLD_H + 120) droplets.splice(i,1);
      }
    }

    function checkLose(){
      if (!alive) return;
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label==="tray" || b.isStatic) continue;
        // out of play area => lose
        if (b.position.y > WORLD_H*1.05 || b.position.x < -60 || b.position.x > WORLD_W + 60) {
          alive = false;
          setState("GAME OVER");
          return;
        }
      }
    }

    function reset(){
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label==="tray" || b.isStatic) continue;
        World.remove(world, b);
      }
      droplets.length = 0;

      alive = true;
      score = 0;
      t = 0;
      spawnEvery = 2.2;
      nextSpawn = 2.2;
      targetAngle = 0;
      Body.setAngle(tray, 0);
      Body.setAngularVelocity(tray, 0);
      setState("OK");
      hintEl.style.opacity = 1;
    }
    restartBtn.addEventListener('click', reset);

    // ---- Rendering (flat) ----
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawBackground(){
      ctx.save();
      const {ox, oy, s} = worldToScreen(0,0);
      ctx.translate(ox, oy);

      ctx.fillStyle = "#121625";
      ctx.fillRect(0,0, WORLD_W*s, WORLD_H*s);

      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = "#9aa3b2";
      ctx.lineWidth = 1;
      const step = 90*s;
      for (let x=0; x<=WORLD_W*s; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_H*s); ctx.stroke(); }
      for (let y=0; y<=WORLD_H*s; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W*s,y); ctx.stroke(); }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function pathVertices(verts){
      ctx.beginPath();
      ctx.moveTo(verts[0].x, verts[0].y);
      for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
      ctx.closePath();
    }

    function drawLiquidInBody(b, ox, oy, s){
      const liq = b.plugin.liquid;

      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      const verts = b.vertices;
      pathVertices(verts);
      ctx.clip();

      const bounds = b.bounds;
      const h = (bounds.max.y - bounds.min.y);

      const levelY = bounds.max.y - h * liq.fill;
      const tilt = liq.slosh;
      const cx = (bounds.min.x + bounds.max.x) * 0.5;

      const y2 = levelY + tilt * (bounds.max.x - cx) * 0.9;
      const y1 = levelY + tilt * (bounds.min.x - cx) * 0.9;

      ctx.fillStyle = liq.color;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 120, bounds.max.y + 120);
      ctx.lineTo(bounds.max.x + 120, bounds.max.y + 120);
      ctx.lineTo(bounds.max.x + 120, y2);
      ctx.lineTo(bounds.min.x - 120, y1);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 60, y1);
      ctx.lineTo(bounds.max.x + 60, y2);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawBody(b){
      const {ox, oy, s} = worldToScreen(0,0);

      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      if (b.label === "tray") {
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);

        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#000";
        roundRect(ctx, -330, -10, 660, 38, 18);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#3b4258";
        roundRect(ctx, -320, -18, 640, 34, 16);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 3;
        roundRect(ctx, -312, -14, 624, 26, 14);
        ctx.stroke();

        ctx.restore();
        ctx.restore();
        return;
      }

      let fill = "#d8e2ff";
      if (b.label==="tumbler") fill = "#cfd8ff";
      if (b.label==="wine") fill = "#d8e2ff";
      if (b.label==="bottle") fill = "#7de0b8";

      ctx.fillStyle = fill;
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 2;

      pathVertices(b.vertices);
      ctx.fill();
      ctx.stroke();

      if (b.plugin && b.plugin.liquid) drawLiquidInBody(b, ox, oy, s);

      ctx.restore();
    }

    function drawArmAndHand(){
      const {ox, oy, s} = worldToScreen(0,0);
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      // arm
      ctx.save();
      ctx.translate(wrist.x, wrist.y + 240);
      ctx.rotate(-0.15);
      ctx.fillStyle = "#b28b68";
      roundRect(ctx, -120, -40, 240, 560, 90);
      ctx.fill();
      ctx.restore();

      // hand (visual follows tray angle)
      ctx.save();
      const a = tray.angle * 0.95;
      ctx.translate(wrist.x, wrist.y + 45);
      ctx.rotate(a);
      ctx.fillStyle = "#caa07a";
      roundRect(ctx, -170, -50, 340, 100, 50);
      ctx.fill();

      ctx.fillStyle = "#d3ac86";
      for (let i=0;i<4;i++){
        roundRect(ctx, -150 + i*75, -98, 60, 56, 22);
        ctx.fill();
      }
      ctx.restore();

      ctx.fillStyle = "rgba(255,255,255,.16)";
      ctx.beginPath();
      ctx.arc(wrist.x, wrist.y, 10, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawDroplets(){
      const {ox, oy, s} = worldToScreen(0,0);
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);
      for (const d of droplets) {
        ctx.globalAlpha = Math.max(0, Math.min(1, d.life));
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(d.x, d.y, 4.2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // ---- Main loop ----
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (alive) {
        t += dt;
        maybeSpawn();
        score += dt * (2 + 0.22 * countItems());
      }

      controlTray(dt);
      Engine.update(engine, dt * 1000);
      lockTrayPosition();
      updateLiquids(dt);
      checkLose();

      drawBackground();
      drawArmAndHand();

      // draw tray then items
      const bodies = Composite.allBodies(world);
      for (const b of bodies) if (b.label==="tray") drawBody(b);
      for (const b of bodies) {
        if (b.label==="tray" || b.isStatic) continue;
        drawBody(b);
      }
      drawDroplets();

      scoreEl.textContent = `Score: ${Math.floor(score)}`;
      itemsEl.textContent = `Items: ${countItems()}/${MAX_ITEMS}`;

      requestAnimationFrame(tick);
    }

    reset();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
