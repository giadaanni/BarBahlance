<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Bar Balance</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=VT323&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0a0a0f;
    display: flex; justify-content: center; align-items: center;
    height: 100vh; overflow: hidden;
    font-family: 'VT323', monospace;
  }
  #game-wrap {
    position: relative;
    width: min(100vh * 0.667, 100vw, 420px);
    aspect-ratio: 2/3;
  }
  canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

  /* â”€â”€ OVERLAY SCREENS â”€â”€ */
  .screen {
    position: absolute; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 20;
  }
  /* â”€â”€ SCREEN 1: COVER â”€â”€ */
  #start-screen {
    cursor: pointer;
    overflow: hidden;
  }
  #cover-bg {
    position: absolute; inset: 0;
    background: url('./ASSET/BarBahlance_mainScreen.jpg')
                no-repeat center center / cover;
  }
  /* Dark gradient at bottom so TAP TO START is readable */
  #cover-bg::after {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.72) 100%);
  }
  #start-screen .start-hint {
    position: relative; z-index: 2;
    font-size: clamp(18px, 4.5vw, 26px);
    letter-spacing: 4px;
    text-shadow: 0 0 20px #f0b429, 0 0 40px #f0b42988;
    color: #fff;
  }

  /* â”€â”€ SCREEN 2: TUTORIAL â”€â”€ */
  #tutorial-screen {
    background: radial-gradient(ellipse at 50% 30%, #1a1035 0%, #0a0a0f 70%);
    gap: 0;
  }
  .tut-deco {
    display: flex; gap: 16px; align-items: flex-end;
    margin-bottom: 18px;
  }
  .tut-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(34px, 9vw, 50px);
    color: #f0b429;
    letter-spacing: 5px;
    text-shadow: 0 0 24px #f0b42966;
    margin-bottom: 22px;
  }
  .tut-rules {
    display: flex; flex-direction: column; gap: 10px;
    width: 82%; max-width: 320px;
  }
  .tut-rule {
    display: flex; align-items: center; gap: 12px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 8px;
    padding: 9px 14px;
    font-size: clamp(13px, 3.2vw, 17px);
    color: #e0e0e0;
    font-family: 'VT323', monospace;
    letter-spacing: 1px;
    line-height: 1.3;
  }
  .tut-rule span { flex: 1; }
  .tut-tagline {
    margin-top: 18px;
    font-size: clamp(12px, 3vw, 16px);
    color: rgba(255,255,255,0.35);
    font-style: italic;
    font-family: 'VT323', monospace;
    letter-spacing: 1px;
  }
  .tut-btn { margin-top: 22px; }

  /* Trophy float on win screen */
  #win-trophy {
    font-size: clamp(60px, 16vw, 88px);
    animation: trophyFloat 1.8s ease-in-out infinite;
    filter: drop-shadow(0 0 20px rgba(240,180,41,0.7));
  }
  @keyframes trophyFloat {
    0%,100% { transform: translateY(0) rotate(-4deg) scale(1); }
    50%      { transform: translateY(-14px) rotate(4deg) scale(1.06); }
  }
  .start-hint { animation: blink 1.2s step-end infinite; }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }
  .deco-g { opacity:.8; animation: float 3s ease-in-out infinite; display:inline-block; }
  @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }

  .game-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(52px, 12vw, 72px);
    letter-spacing: 4px;
    line-height: 1;
    color: #fff;
    text-shadow: 0 0 40px #f0b429, 0 0 80px #f0b42966;
  }
  .title-sub {
    font-size: clamp(16px, 4vw, 22px);
    color: #f0b429;
    letter-spacing: 6px;
    margin-top: 6px;
    text-shadow: 0 0 12px #f0b42988;
  }

  /* â”€â”€ HUD â”€â”€ */
  #hud {
    position: absolute; top: 0; left: 0; right: 0;
    padding: 10px 14px;
    display: none;
    justify-content: space-between; align-items: flex-start;
    z-index: 15; pointer-events: none;
  }
  .hud-pill {
    background: rgba(0,0,0,.55);
    border: 1.5px solid rgba(255,255,255,.18);
    border-radius: 6px;
    padding: 4px 12px;
    font-size: clamp(14px, 3.5vw, 20px);
    color: #fff;
    text-shadow: 0 0 8px #f0b42966;
  }
  .hud-level { color: #f0b429; }

  /* Countdown ring */
  #countdown-wrap {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    display: none; flex-direction: column; align-items: center;
    z-index: 15; pointer-events: none;
  }
  #countdown-label {
    font-size: clamp(13px, 3vw, 18px);
    color: #aaa; letter-spacing: 2px; margin-bottom: 4px;
  }
  #countdown-num {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(48px, 11vw, 64px);
    color: #f0b429;
    text-shadow: 0 0 24px #f0b429;
    line-height: 1;
  }
  #countdown-bar-wrap {
    width: 140px; height: 6px;
    background: rgba(255,255,255,.1); border-radius: 3px; margin-top: 8px; overflow: hidden;
  }
  #countdown-bar { height: 100%; background: #f0b429; border-radius: 3px; transition: width 0.9s linear; }

  /* â”€â”€ GAME OVER â”€â”€ */
  #gameover-screen {
    background: rgba(0,0,0,.88);
    display: none;
  }
  .crash-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(56px, 14vw, 80px);
    color: #e53e3e;
    text-shadow: 0 0 30px #e53e3e88;
    letter-spacing: 4px;
  }
  .score-line {
    font-size: clamp(18px, 4vw, 24px);
    color: #ccc; margin-top: 10px; letter-spacing: 1px;
  }
  .score-line span { color: #f0b429; }
  .btn {
    margin-top: 32px;
    padding: 14px 36px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(20px, 5vw, 28px);
    letter-spacing: 3px;
    background: #f0b429;
    color: #0a0a0f;
    border: none; border-radius: 4px;
    cursor: pointer;
    transition: transform .1s, box-shadow .1s;
    box-shadow: 0 4px 0 #a07a1a;
  }
  .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #a07a1a; }

  /* â”€â”€ WIN â”€â”€ */
  #win-screen {
    background: rgba(0,0,0,.88);
    display: none;
  }
  .win-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(44px, 11vw, 64px);
    color: #f0b429;
    text-shadow: 0 0 30px #f0b42988;
    letter-spacing: 4px;
    text-align: center;
  }

  /* Spawn indicator */
  #spawn-indicator {
    position: absolute; top: 0; left: 50%; transform: translateX(-50%);
    font-size: 28px; pointer-events: none; z-index: 14;
    transition: opacity .3s;
    opacity: 0;
  }
  #spawn-indicator.show { opacity: 1; }

  /* Tilt warning */
  #tilt-warn {
    position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%);
    font-size: clamp(14px, 3.5vw, 20px);
    color: #e53e3e;
    text-shadow: 0 0 12px #e53e3e;
    letter-spacing: 2px;
    pointer-events: none; z-index: 14;
    opacity: 0; transition: opacity .2s;
  }
  #tilt-warn.show { opacity: 1; animation: tiltPulse .4s ease infinite alternate; }
  @keyframes tiltPulse { from{text-shadow:0 0 8px #e53e3e} to{text-shadow:0 0 24px #e53e3e} }

  /* Score bar */
  #score-bar {
    position: absolute; bottom: 200px; left: 0; right: 0;
    display: none;
    justify-content: space-between;
    padding: 0 14px;
    pointer-events: none; z-index: 15;
    font-size: clamp(16px, 4vw, 22px);
  }
  #score-disp { color: #fff; text-shadow: 0 0 8px #f0b42966; }
  #best-disp  { color: #f0b429; text-shadow: 0 0 8px #f0b42966; }

  /* Big score on game-over/win screens */
  .go-score-big {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(44px, 11vw, 64px);
    color: #fff;
    text-shadow: 0 0 20px rgba(255,255,255,0.4);
    margin-top: 6px;
    letter-spacing: 3px;
  }
</style>
</head>
<body>
<div id="game-wrap">
  <!-- SCREEN 1: COVER -->
  <div id="start-screen" class="screen" onclick="showTutorial()">
    <div id="cover-bg"></div>
    <div class="start-hint" style="margin-top:0; position:absolute; bottom: 12%;">TAP TO START</div>
  </div>

  <!-- SCREEN 2: TUTORIAL -->
  <div id="tutorial-screen" class="screen" style="display:none;">
    <div class="tut-deco" aria-hidden="true">
      <span class="deco-g" style="font-size:44px">ğŸº</span>
      <span class="deco-g" style="font-size:32px;animation-delay:.3s">ğŸ·</span>
      <span class="deco-g" style="font-size:48px;animation-delay:.6s">ğŸ¹</span>
      <span class="deco-g" style="font-size:28px;animation-delay:.9s">ğŸ¥‚</span>
      <span class="deco-g" style="font-size:38px;animation-delay:1.2s">ğŸ¸</span>
    </div>
    <div class="tut-title">HOW TO PLAY</div>
    <div class="tut-rules">
      <div class="tut-rule">ğŸ¤š <span>Move your hand to balance the tray</span></div>
      <div class="tut-rule">ğŸº <span>Drinks will fall â€” catch them all!</span></div>
      <div class="tut-rule">âš–ï¸ <span>Don't let the tray tilt too far</span></div>
      <div class="tut-rule">ğŸ <span>Hold steady for 5 seconds to pass</span></div>
    </div>
    <div class="tut-tagline">"Deliver the round without the drama!"</div>
    <button class="btn tut-btn" onclick="startGame()">START GAME</button>
  </div>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-pill hud-level" id="lvl-disp">LV 1</div>
    <div class="hud-pill" id="tilt-disp" style="font-size:clamp(11px,2.8vw,16px);">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</div>
    <div class="hud-pill" id="items-disp">0 / 3</div>
  </div>
  <!-- Score bar -->
  <div id="score-bar">
    <div id="score-disp">0</div>
    <div id="best-disp">â˜… 0</div>
  </div>
  <div id="spawn-indicator">â¬‡ï¸</div>
  <div id="tilt-warn">âš  TILT!</div>

  <!-- COUNTDOWN -->
  <div id="countdown-wrap">
    <div id="countdown-label">HOLD STEADY</div>
    <div id="countdown-num">8</div>
    <div id="countdown-bar-wrap"><div id="countdown-bar" style="width:100%"></div></div>
  </div>

  <!-- GAMEOVER -->
  <div id="gameover-screen" class="screen">
    <div class="crash-title">CRASH!</div>
    <div id="go-quip" style="
      font-size:clamp(13px,3.2vw,18px);color:rgba(255,255,255,0.55);
      font-family:'VT323',monospace;letter-spacing:1px;
      margin-top:6px;text-align:center;padding:0 24px;line-height:1.4;
      max-width:85%;font-style:italic;
    "></div>
    <div class="score-line" style="margin-top:12px">Level <span id="go-level">1</span></div>
    <div class="go-score-big" id="go-score">0</div>
    <div class="score-line" style="font-size:clamp(13px,3vw,18px);margin-top:4px;">
      BEST&nbsp;<span id="go-best" style="color:#f0b429">0</span>
    </div>
    <div id="go-items" style="
      margin-top:14px; font-size:clamp(11px,2.6vw,15px);
      color:#aaa; max-width:80%; text-align:center; line-height:1.8;
      font-family:'VT323',monospace; letter-spacing:1px;
    "></div>
    <button class="btn" onclick="resetGame()">RETRY</button>
  </div>

  <!-- WIN -->
  <div id="win-screen" class="screen" style="cursor:pointer;" onclick="fullReset()">
    <div id="win-trophy">ğŸ†</div>
    <div class="win-title" style="margin-top:10px">BAR MASTER!</div>
    <div class="score-line" style="margin-top:10px;font-size:clamp(14px,3.5vw,20px)">
      All 5 levels cleared!
    </div>
    <div class="go-score-big" id="win-score">0</div>
    <div class="score-line" style="font-size:clamp(13px,3vw,18px);margin-top:4px;">
      BEST&nbsp;<span id="win-best" style="color:#f0b429">0</span>
    </div>
    <div class="start-hint" style="margin-top:32px;font-size:clamp(14px,3.5vw,20px)">
      TAP TO PLAY AGAIN
    </div>
  </div>
</div>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CONSTANTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const W = 420, H = 630;
const TRAY_W = 280, TRAY_H = 14;
const TRAY_Y = H - 180;
const HAND_Y = H - 80;
const LEVELS = [3, 5, 7, 10, 13];
const SPAWN_INTERVAL = 2800; // ms
const WIN_HOLD_SECS = 5;
const MAX_TRAY_ANGLE = Math.PI * 0.22; // ~40Â° â€” tighter, more skill-based limit

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let engine, render, runner, tray, trayPivotConstraint;
let items = [];
let currentLevelIdx = 0;
let spawnedCount = 0;
let isGameOver = false;
let isCountingDown = false;
let spawnTimer = null;
let countTimer = null;
let mouseX = W / 2;
let smoothX = W / 2;
let lastSpawnX = W / 2;
let trayAngle = 0;

// Score
let score = 0;
let bestScore = parseInt(localStorage.getItem('barbalance_best') || '0');
let landedItems = [];      // tracks which items have landed (for score + game over screen)
let particles  = [];       // visual particle bursts
let nextItemDef = null;    // pre-picked next item def (shown as preview)
let vignetteAlpha = 0;     // red vignette intensity (danger feedback)
let bombTimers    = [];    // active bomb countdowns: { body, timeLeft, interval }

const { Engine, Render, Runner, Bodies, Body, Composite, Events, Constraint, Vector } = Matter;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ITEM DEFINITIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// score = points awarded when item lands safely; heavier/taller = more points
const ITEM_DEFS = [
  { id:'calice',   label:'Calice di Vino',    w:32, h:72,  density:0.004, score:150 },
  { id:'boccale',  label:'Boccale di Birra',  w:50, h:68,  density:0.010, score:300 },
  { id:'cocktail', label:'Cocktail',          w:40, h:58,  density:0.005, score:200 },
  { id:'acqua',    label:'Acqua',             w:26, h:78,  density:0.006, score:100 },
  { id:'birra',    label:'Birra in Bottiglia',w:24, h:88,  density:0.007, score:250 },
  { id:'chupito',  label:'Chupito',           w:20, h:36,  density:0.003, score: 75 },
];
// Special hazard items â€” only appear in levels 4-5 (index 3-4)
const HAZARD_DEFS = [
  { id:'piccione', label:'Piccione',  w:38, h:30, density:0.006, score:0,
    restitution:0.05, friction:0.7 },
  { id:'bomba',    label:'Bomba',     w:36, h:36, density:0.005, score:0,
    restitution:0.82, friction:0.1, isBomb:true },
];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  INIT ENGINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initEngine() {
  // Gravity increases with level: 1.2 â†’ 1.8 by level 5
  const gravityScale = 1.2 + currentLevelIdx * 0.15;
  engine = Engine.create({ gravity: { y: gravityScale } });

  const container = document.getElementById('game-wrap');
  // Remove old canvas if any
  const old = container.querySelector('canvas');
  if (old) old.remove();

  render = Render.create({
    element: container,
    engine,
    options: { width: W, height: H, wireframes: false, background: 'transparent' }
  });

  runner = Runner.create();

  // Mouse / Touch tracking
  const updateMouse = (e) => {
    e.preventDefault();
    const rect = render.canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    mouseX = (cx - rect.left) * (W / rect.width);
    mouseX = Math.max(40, Math.min(W - 40, mouseX));
  };
  render.canvas.addEventListener('mousemove', updateMouse);
  render.canvas.addEventListener('touchmove', updateMouse, { passive: false });

  // Physics: move the pivot point under the tray smoothly
  Events.on(engine, 'beforeUpdate', physicsUpdate);

  // Render hook: draw hand, check loss
  Events.on(render, 'afterRender', afterRender);

  Render.run(render);
  Runner.run(runner, engine);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SETUP LEVEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupLevel() {
  // Clear world
  Composite.clear(engine.world);
  items = [];
  landedItems = [];
  particles = [];
  bombTimers.forEach(bt => clearInterval(bt.interval));
  bombTimers = [];
  spawnedCount = 0;
  isGameOver = false;
  isCountingDown = false;
  clearInterval(spawnTimer);
  clearInterval(countTimer);
  smoothX = W / 2;
  trayAngle = 0;
  vignetteAlpha = 0;
  // Score persists across levels; only reset on full game reset (resetGame)
  nextItemDef = pickRandomDef(); // pre-pick first preview

  // UI
  document.getElementById('hud').style.display      = 'flex';
  document.getElementById('score-bar').style.display = 'flex';
  document.getElementById('countdown-wrap').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
  document.getElementById('tilt-warn').classList.remove('show');
  updateHUD();

  // No side walls â€” items must be kept on tray, can fall off any edge

  // TRAY â€” kinematic body (very high mass but we set position manually)
  tray = Bodies.rectangle(W/2, TRAY_Y, TRAY_W, TRAY_H, {
    label: 'tray',
    friction: 0.9,
    frictionStatic: 1.0,
    restitution: 0.01,
    density: 0.6,           // heavy tray = collision impacts don't spin it wildly
    render: { fillStyle: '#d0d0c8' },
    collisionFilter: { category: 0x0001, mask: 0x0002 }
  });
  Body.setStatic(tray, false);
  Composite.add(engine.world, tray);

  // Start spawning
  startSpawning();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PHYSICS UPDATE (runs every tick)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Design: the tray angle changes SLOWLY via lerp â€” it "drifts" toward
// the imbalance rather than reacting instantly. Collisions from Matter
// are neutralized by zeroing angular velocity every tick, so a falling
// bottle doesn't cause a violent spin. The lean builds up gradually,
// giving the player time to compensate.

function physicsUpdate() {
  if (isGameOver || !tray) return;

  smoothX += (mouseX - smoothX) * 0.12;
  Body.setPosition(tray, { x: smoothX, y: TRAY_Y });
  Body.setVelocity(tray, { x: 0, y: 0 });
  Body.setAngularVelocity(tray, 0);

  // â”€â”€ Landing detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  items.forEach(item => {
    if (item._landed) return;
    const dy    = item.position.y - tray.position.y;
    const speed = Math.sqrt(item.velocity.x**2 + item.velocity.y**2);
    const onTray = dy > -item._def.h && dy < 20 &&
                   speed < 1.5 &&
                   Math.abs(item.position.x - tray.position.x) < TRAY_W / 2 + 10;
    if (!onTray) return;

    item._landed = true;

    if (item._def.isBomb && !item._bombLit) {
      // Bomb lands â†’ start 5s fuse
      item._bombLit = true;
      item._bombTime = 5;
      spawnFloatingText('ğŸ’£ 5s!', item.position.x, item.position.y - 30, '#ff4444');
      const bt = {
        body: item,
        timeLeft: 5,
        interval: setInterval(() => {
          bt.timeLeft--;
          item._bombTime = bt.timeLeft;
          if (bt.timeLeft <= 0) {
            clearInterval(bt.interval);
            // If bomb is still on tray â†’ BOOM
            const stillNear = Math.abs(item.position.x - tray.position.x) < TRAY_W / 2 + 30 &&
                              item.position.y < H + 100;
            if (stillNear && !isGameOver) explodeBomb(item);
          }
        }, 1000)
      };
      bombTimers.push(bt);
    } else if (!item._def.isBomb && item._def.id !== 'piccione') {
      // Normal drink lands â†’ award score
      landedItems.push(item._def);
      awardScore(item._def, item.position);
      spawnLandParticles(item.position.x, item.position.y - item._def.h / 2, item._def);
    }
  });

  // â”€â”€ Weight imbalance â†’ target angle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let totalMass = 0, weightedX = 0;
  items.forEach(item => {
    const dy = item.position.y - tray.position.y;
    if (dy > -200 && dy < 80) {
      weightedX += (item.position.x - tray.position.x) * item.mass;
      totalMass  += item.mass;
    }
  });
  const comOffset   = totalMass > 0 ? weightedX / totalMass : 0;
  // Tilt sensitivity increases slightly with level
  const sensitivity = 0.010 + currentLevelIdx * 0.002;
  const targetAngle = Math.max(-0.44, Math.min(0.44, comOffset * sensitivity));

  // Lerp speed also increases with level: 0.008 â†’ 0.016 by level 5
  const lerpSpeed = 0.008 + currentLevelIdx * 0.0016;
  trayAngle += (targetAngle - trayAngle) * lerpSpeed;
  Body.setAngle(tray, trayAngle);

  // â”€â”€ Particle physics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x  += p.vx;
    p.y  += p.vy;
    p.vy += 0.18;  // mini gravity
    p.life -= 1;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BOMB EXPLOSION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function explodeBomb(bombBody) {
  if (isGameOver) return;
  // Big explosion particle burst
  const x = bombBody.position.x, y = bombBody.position.y;
  for (let i = 0; i < 40; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 6;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 3,
      life: 35 + Math.random() * 20,
      maxLife: 55,
      size: 3 + Math.random() * 5,
      color: Math.random() < 0.5 ? '#ff6600' : (Math.random() < 0.5 ? '#ffcc00' : '#ff2200')
    });
  }
  // Override game over message
  const quipEl = document.getElementById('go-quip');
  if (quipEl) quipEl.innerText = '"BOOM. That\'s on you."';
  triggerGameOver();
}
function awardScore(def, pos) {
  const pts = def.score;
  score += pts;
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('barbalance_best', bestScore);
  }
  updateHUD();
  // Floating +pts text
  spawnFloatingText('+' + pts, pos.x, pos.y - 20, def.id === 'boccale' ? '#f0b429' : '#fff');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PARTICLES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Colour palette per item type
const ITEM_COLORS = {
  calice:'#c0392b', boccale:'#f0a020', cocktail:'#ff3d9a',
  acqua:'#3498db',  birra:'#3a5c22',   chupito:'#f0b429',
  piccione:'#aaaaaa', bomba:'#222222'
};

function spawnLandParticles(x, y, def) {
  const col = ITEM_COLORS[def.id] || '#fff';
  const count = def.id === 'boccale' ? 18 : 10;
  for (let i = 0; i < count; i++) {
    const angle = (Math.random() * Math.PI * 2);
    const speed = 1.5 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      life: 28 + Math.random() * 14,
      maxLife: 42,
      size: 2 + Math.random() * 3,
      color: col
    });
  }
}

// Floating score text pool
const floatingTexts = [];
function spawnFloatingText(text, x, y, color) {
  floatingTexts.push({ text, x, y, vy: -1.2, life: 50, color });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  NEXT ITEM PREVIEW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateNextPreview() {
  const el = document.getElementById('next-preview-label');
  if (el && nextItemDef) el.innerText = nextItemDef.label.toUpperCase();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  AFTER RENDER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function afterRender() {
  if (isGameOver) return;
  drawScene();
  checkLoseCondition();
}

function drawScene() {
  const ctx = render.context;

  // Background gradient
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, '#12101e');
  bg.addColorStop(1, '#1a1428');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Background PNG overlay at 50% opacity
  if (window._bgImg && window._bgImg.complete) {
    ctx.globalAlpha = 0.5;
    ctx.drawImage(window._bgImg, 0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  // Subtle ambient light dots in background
  ctx.fillStyle = 'rgba(255,200,80,0.03)';
  for(let i=0;i<6;i++){
    ctx.beginPath();
    ctx.arc(60+i*60, 80+i*30, 40, 0, Math.PI*2);
    ctx.fill();
  }

  // Bar counter at bottom
  ctx.fillStyle = '#2a1f10';
  ctx.fillRect(0, HAND_Y - 20, W, H - HAND_Y + 20);
  ctx.fillStyle = '#3d2b12';
  ctx.fillRect(0, HAND_Y - 20, W, 18);
  // wood grain lines
  for (let i = 0; i < W; i += 22) {
    ctx.strokeStyle = 'rgba(0,0,0,.18)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(i, HAND_Y - 20); ctx.lineTo(i + 8, H); ctx.stroke();
  }

  // Floor glow under hand
  const glow = ctx.createRadialGradient(smoothX, HAND_Y - 10, 0, smoothX, HAND_Y - 10, 160);
  glow.addColorStop(0, 'rgba(240,180,41,0.12)');
  glow.addColorStop(1, 'rgba(240,180,41,0)');
  ctx.fillStyle = glow;
  ctx.fillRect(0, HAND_Y - 30, W, H);

  // ARM
  drawArm(ctx, smoothX, HAND_Y, W / 2, H + 60);

  // Items â€” each with iconic shape
  items.forEach(item => {
    if (!item._def) return;
    const p = item.position;
    const a = item.angle;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(a);
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
    drawItem(ctx, item._def);
    ctx.shadowColor = 'transparent';
    ctx.restore();
    // Bomb countdown drawn in world space (not rotated)
    if (item._def.isBomb) drawBombTimer(ctx, item);
  });

  // TRAY (drawn on top so it visually overlaps items resting on it)
  drawTray(ctx);

  // â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // â”€â”€ Floating score texts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y  += t.vy;
    t.life -= 1;
    if (t.life <= 0) { floatingTexts.splice(i, 1); continue; }
    ctx.globalAlpha = Math.min(1, t.life / 20);
    ctx.fillStyle = t.color;
    ctx.font = "bold 18px 'Bebas Neue', sans-serif";
    ctx.textAlign = 'center';
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // â”€â”€ Next item preview (top-right ghost) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawNextPreview(ctx);

  // â”€â”€ Danger vignette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (vignetteAlpha > 0) {
    const vg = ctx.createRadialGradient(W/2, H/2, H*0.28, W/2, H/2, H*0.78);
    vg.addColorStop(0, 'rgba(220,30,30,0)');
    vg.addColorStop(1, `rgba(220,30,30,${vignetteAlpha.toFixed(2)})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
  }
}

// â”€â”€ MASTER ITEM DISPATCHER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawItem(ctx, def) {
  switch(def.id) {
    case 'calice':   drawCalice(ctx, def); break;
    case 'boccale':  drawBoccale(ctx, def); break;
    case 'cocktail': drawCocktail(ctx, def); break;
    case 'acqua':    drawAcqua(ctx, def); break;
    case 'birra':    drawBirraBottiglia(ctx, def); break;
    case 'chupito':  drawChupito(ctx, def); break;
    case 'piccione': drawPiccione(ctx, def); break;
    case 'bomba':    drawBomba(ctx, def); break;
  }
}

// â”€â”€ PICCIONE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPiccione(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  ctx.save();
  // Body â€” fat teardrop
  ctx.beginPath();
  ctx.ellipse(0, 2, hw*0.78, hh*0.72, 0, 0, Math.PI*2);
  ctx.fillStyle = '#9e9e9e'; ctx.fill();
  ctx.strokeStyle = '#555'; ctx.lineWidth = 1.2; ctx.stroke();

  // Wing highlight
  ctx.beginPath();
  ctx.ellipse(-4, 0, hw*0.55, hh*0.45, -0.2, 0, Math.PI*2);
  ctx.fillStyle = '#b8b8b8'; ctx.fill();

  // Wing feather lines
  ctx.strokeStyle = '#777'; ctx.lineWidth = 0.8;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(-hw*0.5 + i*5, hh*0.1);
    ctx.lineTo(-hw*0.5 + i*5 + 2, hh*0.55);
    ctx.stroke();
  }

  // Head
  ctx.beginPath();
  ctx.arc(hw*0.5, -hh*0.35, hh*0.32, 0, Math.PI*2);
  ctx.fillStyle = '#8a8a8a'; ctx.fill();
  ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.stroke();

  // Iridescent neck patch
  ctx.beginPath();
  ctx.ellipse(hw*0.3, -hh*0.08, 8, 5, 0.3, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(100,180,120,0.55)'; ctx.fill();

  // Eye
  ctx.beginPath();
  ctx.arc(hw*0.62, -hh*0.4, 2.5, 0, Math.PI*2);
  ctx.fillStyle = '#1a1a1a'; ctx.fill();
  ctx.beginPath();
  ctx.arc(hw*0.63, -hh*0.41, 0.8, 0, Math.PI*2);
  ctx.fillStyle = '#fff'; ctx.fill();

  // Beak
  ctx.beginPath();
  ctx.moveTo(hw*0.85, -hh*0.38);
  ctx.lineTo(hw*1.1,  -hh*0.30);
  ctx.lineTo(hw*0.85, -hh*0.22);
  ctx.closePath();
  ctx.fillStyle = '#c8b040'; ctx.fill();

  // Feet
  ctx.strokeStyle = '#c8b040'; ctx.lineWidth = 1.2; ctx.lineCap = 'round';
  [[-8, 1], [4, 1]].forEach(([fx]) => {
    ctx.beginPath(); ctx.moveTo(fx, hh*0.85); ctx.lineTo(fx - 4, hh*1.05); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(fx, hh*0.85); ctx.lineTo(fx,     hh*1.1);  ctx.stroke();
    ctx.beginPath(); ctx.moveTo(fx, hh*0.85); ctx.lineTo(fx + 5, hh*1.05); ctx.stroke();
  });
  ctx.restore();
}

// â”€â”€ BOMBA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBomba(ctx, d) {
  const r = d.w / 2;
  ctx.save();

  // Main ball â€” glossy black
  const ballGrad = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.05, 0, 0, r);
  ballGrad.addColorStop(0,   '#666');
  ballGrad.addColorStop(0.4, '#222');
  ballGrad.addColorStop(1,   '#000');
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI*2);
  ctx.fillStyle = ballGrad;
  ctx.fill();
  ctx.strokeStyle = '#111'; ctx.lineWidth = 1.5; ctx.stroke();

  // Shine
  ctx.beginPath();
  ctx.ellipse(-r*0.28, -r*0.3, r*0.22, r*0.15, -0.5, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.22)'; ctx.fill();

  // Fuse rope (curved line from top)
  ctx.beginPath();
  ctx.moveTo(r*0.1, -r);
  ctx.bezierCurveTo(r*0.3, -r*1.4, r*0.7, -r*1.5, r*0.55, -r*1.85);
  ctx.strokeStyle = '#8B6914'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
  ctx.stroke();

  // Fuse flame (always lit â€” animated via _bombTime)
  ctx.beginPath();
  ctx.arc(r*0.55, -r*1.88, 4, 0, Math.PI*2);
  ctx.fillStyle = '#ff6600'; ctx.fill();
  ctx.beginPath();
  ctx.arc(r*0.55 + 1, -r*1.92, 2.5, 0, Math.PI*2);
  ctx.fillStyle = '#ffdd00'; ctx.fill();

  ctx.restore();
}

// Draw bomb countdown timer above the bomb body (called in drawScene items loop)
function drawBombTimer(ctx, item) {
  if (!item._bombLit || item._bombTime === undefined) return;
  const p = item.position;
  const t = item._bombTime;
  const col = t <= 2 ? '#ff2200' : t <= 3 ? '#ff6600' : '#ffcc00';
  ctx.save();
  ctx.font = `bold ${t <= 2 ? 20 : 16}px 'Bebas Neue', sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillStyle = col;
  ctx.shadowColor = col; ctx.shadowBlur = 10;
  ctx.fillText(t + 's', p.x, p.y - item._def.w / 2 - 8);
  // Pulsing ring when critical
  if (t <= 2) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, item._def.w / 2 + 4, 0, Math.PI*2);
    ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
    ctx.stroke();
  }
  ctx.restore();
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

// â”€â”€ CALICE DI VINO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Goblet: wide rim â†’ tapering body â†’ thin stem â†’ flat base
function drawCalice(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  // Bowl (trapezoid, wider at top)
  ctx.beginPath();
  ctx.moveTo(-hw, -hh);           // top-left rim
  ctx.lineTo( hw, -hh);           // top-right rim
  ctx.lineTo( hw*0.45,  hh*0.15); // bottom-right of bowl
  ctx.lineTo(-hw*0.45,  hh*0.15); // bottom-left of bowl
  ctx.closePath();
  // Wine fill
  const wineGrad = ctx.createLinearGradient(-hw, -hh, hw, -hh);
  wineGrad.addColorStop(0, '#7b1520');
  wineGrad.addColorStop(0.4, '#c0392b');
  wineGrad.addColorStop(1, '#7b1520');
  ctx.fillStyle = wineGrad;
  ctx.fill();
  // Glass overlay (semi-transparent)
  ctx.beginPath();
  ctx.moveTo(-hw, -hh);
  ctx.lineTo( hw, -hh);
  ctx.lineTo( hw*0.45,  hh*0.15);
  ctx.lineTo(-hw*0.45,  hh*0.15);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 1.2;
  ctx.stroke();
  // Rim highlight
  ctx.beginPath();
  ctx.moveTo(-hw+2, -hh+2);
  ctx.lineTo(hw*0.6, -hh+2);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Stem
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fillRect(-2.5, hh*0.15, 5, hh*0.62);
  // Base
  ctx.beginPath();
  ctx.ellipse(0, hh*0.77, hw*0.65, 4, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fill();
}

// â”€â”€ BOCCALE DI BIRRA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pint glass: slight taper, amber beer, white foam head, handle bump
function drawBoccale(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  const foamH = hh * 0.22; // foam occupies top 22%

  // Glass body (slightly wider at top)
  ctx.beginPath();
  ctx.moveTo(-hw*0.82, -hh);
  ctx.lineTo( hw*0.82, -hh);
  ctx.lineTo( hw,       hh);
  ctx.lineTo(-hw,       hh);
  ctx.closePath();
  // Beer gradient
  const beerGrad = ctx.createLinearGradient(-hw, -hh, hw, 0);
  beerGrad.addColorStop(0, '#d4820a');
  beerGrad.addColorStop(0.5,'#f0a020');
  beerGrad.addColorStop(1, '#c06010');
  ctx.fillStyle = beerGrad;
  ctx.fill();
  // Glass shine overlay
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.fill();

  // Foam â€” sits on top of beer
  ctx.save();
  ctx.clip(); // clip foam to glass shape
  ctx.beginPath();
  // Bumpy foam top
  const foamY = -hh + foamH;
  ctx.moveTo(-hw*0.82, -hh);
  // left side up
  for(let bx = -hw*0.78; bx <= hw*0.78; bx += 7) {
    ctx.arc(bx, -hh + 5, 5, Math.PI, 0);
  }
  ctx.lineTo(hw*0.82, -hh);
  ctx.lineTo(hw*0.82, foamY);
  ctx.lineTo(-hw*0.82, foamY);
  ctx.closePath();
  ctx.fillStyle = '#f5f0e8';
  ctx.fill();
  ctx.restore();

  // Glass outline
  ctx.beginPath();
  ctx.moveTo(-hw*0.82, -hh);
  ctx.lineTo( hw*0.82, -hh);
  ctx.lineTo( hw,       hh);
  ctx.lineTo(-hw,       hh);
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Handle (right side bump)
  ctx.beginPath();
  ctx.arc(hw + 7, -hh*0.1, 10, -Math.PI*0.6, Math.PI*0.6);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 5;
  ctx.stroke();
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Glass highlight stripe
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.beginPath();
  ctx.moveTo(-hw*0.68, -hh + foamH + 4);
  ctx.lineTo(-hw*0.45, -hh + foamH + 4);
  ctx.lineTo(-hw*0.52, hh - 6);
  ctx.lineTo(-hw*0.75, hh - 6);
  ctx.closePath();
  ctx.fill();
}

// â”€â”€ COCKTAIL (Martini-style) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Wide inverted triangle bowl, thin stem, flat base, umbrella straw
function drawCocktail(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  const bowlBottom = hh * 0.05;
  const stemTop = bowlBottom;
  const stemBot = hh * 0.72;

  // Bowl
  ctx.beginPath();
  ctx.moveTo(-hw, -hh);
  ctx.lineTo( hw, -hh);
  ctx.lineTo(0, bowlBottom);
  ctx.closePath();
  const cGrad = ctx.createLinearGradient(-hw,-hh, hw, 0);
  cGrad.addColorStop(0,'#ff6eb0');
  cGrad.addColorStop(0.5,'#ff3d9a');
  cGrad.addColorStop(1,'#c4007a');
  ctx.fillStyle = cGrad;
  ctx.fill();
  // Glass overlay
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1.2;
  ctx.stroke();
  // Rim highlight
  ctx.beginPath();
  ctx.moveTo(-hw+3, -hh+3);
  ctx.lineTo(hw*0.5, -hh+3);
  ctx.strokeStyle='rgba(255,255,255,0.55)';
  ctx.lineWidth=1.5; ctx.stroke();
  // Stem
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillRect(-2, stemTop, 4, stemBot - stemTop);
  // Base
  ctx.beginPath();
  ctx.ellipse(0, stemBot, hw*0.65, 4, 0, 0, Math.PI*2);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fill();
  // Umbrella/straw
  ctx.save();
  ctx.translate(hw*0.3, -hh + 4);
  // straw
  ctx.strokeStyle='#f0b429'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-6, bowlBottom - 6); ctx.stroke();
  // tiny umbrella
  ctx.beginPath();
  ctx.arc(0,0, 8, Math.PI, 0);
  ctx.fillStyle='#ff6b35'; ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=0.8; ctx.stroke();
  ctx.restore();
}

// â”€â”€ ACQUA (plastic bottle) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Slim bottle with label band, cap, indentations
function drawAcqua(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  const capH = hh * 0.12;
  const neckH = hh * 0.14;
  const neckW = hw * 0.55;
  const bodyTop = -hh + capH + neckH;

  // Bottle body
  ctx.beginPath();
  ctx.moveTo(-hw, bodyTop);
  ctx.lineTo( hw, bodyTop);
  ctx.lineTo( hw,  hh);
  ctx.lineTo(-hw,  hh);
  ctx.closePath();
  const waterGrad = ctx.createLinearGradient(-hw, 0, hw, 0);
  waterGrad.addColorStop(0, '#1a6fa8');
  waterGrad.addColorStop(0.35,'#3498db');
  waterGrad.addColorStop(0.65,'#5dade2');
  waterGrad.addColorStop(1, '#1a6fa8');
  ctx.fillStyle = waterGrad;
  ctx.fill();

  // Neck taper
  ctx.beginPath();
  ctx.moveTo(-neckW, -hh + capH);
  ctx.lineTo( neckW, -hh + capH);
  ctx.lineTo( hw, bodyTop);
  ctx.lineTo(-hw, bodyTop);
  ctx.closePath();
  ctx.fillStyle='#2e86c1'; ctx.fill();

  // Cap
  ctx.beginPath();
  ctx.moveTo(-neckW * 0.8, -hh);
  ctx.lineTo( neckW * 0.8, -hh);
  ctx.lineTo( neckW, -hh + capH);
  ctx.lineTo(-neckW, -hh + capH);
  ctx.closePath();
  ctx.fillStyle='#f0b429'; ctx.fill(); // yellow cap
  ctx.strokeStyle='#c8921a'; ctx.lineWidth=1; ctx.stroke();

  // Label band
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(-hw+1, -hh*0.15, d.w-2, hh*0.55);
  // Label text hint
  ctx.fillStyle='rgba(255,255,255,0.55)';
  ctx.fillRect(-hw*0.7, -hh*0.05, hw*1.4, 2.5);
  ctx.fillRect(-hw*0.7,  hh*0.1,  hw*1.4, 2.5);

  // Indentation lines (plastic bottle details)
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  for(let iy = hh*0.38; iy < hh - 6; iy += hh*0.18){
    ctx.beginPath(); ctx.moveTo(-hw+2, iy); ctx.lineTo(hw-2, iy); ctx.stroke();
  }

  // Highlight
  ctx.fillStyle='rgba(255,255,255,0.22)';
  ctx.fillRect(-hw+3, bodyTop+4, hw*0.45, hh*1.7);
  // Bottle outline
  ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(-hw, bodyTop); ctx.lineTo(-hw, hh); ctx.lineTo(hw, hh); ctx.lineTo(hw, bodyTop); ctx.stroke();
}

// â”€â”€ BIRRA IN BOTTIGLIA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Dark glass beer bottle: narrow neck, shoulder, body, label
function drawBirraBottiglia(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  const capH  = hh * 0.08;
  const neckH = hh * 0.30;
  const neckW = hw * 0.42;
  const shoulderH = hh * 0.12;
  const bodyTop   = -hh + capH + neckH + shoulderH;

  // Body â€” strictly within [-hh, +hh]
  ctx.beginPath();
  ctx.rect(-hw, bodyTop, d.w, hh - bodyTop);
  const bottleGrad = ctx.createLinearGradient(-hw, 0, hw, 0);
  bottleGrad.addColorStop(0,  '#1a2e1a');
  bottleGrad.addColorStop(0.3,'#2e4d1e');
  bottleGrad.addColorStop(0.6,'#3a5c22');
  bottleGrad.addColorStop(1,  '#1a2e1a');
  ctx.fillStyle = bottleGrad;
  ctx.fill();

  // Shoulder
  ctx.beginPath();
  ctx.moveTo(-neckW, -hh + capH + neckH);
  ctx.lineTo( neckW, -hh + capH + neckH);
  ctx.lineTo( hw,    bodyTop);
  ctx.lineTo(-hw,    bodyTop);
  ctx.closePath();
  ctx.fillStyle='#243d18'; ctx.fill();

  // Neck
  ctx.fillStyle='#2e4d1e';
  ctx.fillRect(-neckW, -hh + capH, neckW*2, neckH);

  // Cap (crown cap â€” flat)
  ctx.beginPath();
  ctx.rect(-neckW*1.1, -hh, neckW*2.2, capH);
  ctx.fillStyle='#c0392b'; ctx.fill();
  ctx.strokeStyle='#922b21'; ctx.lineWidth=0.8; ctx.stroke();
  // Crown notches
  ctx.fillStyle='#e74c3c';
  for(let nx=-neckW*0.9; nx<neckW*0.9; nx+=4){
    ctx.fillRect(nx, -hh, 2, 2.5);
  }

  // Label
  const labelTop = bodyTop + hh*0.10;
  const labelH   = hh * 0.60;
  ctx.fillStyle='#f0e8c8';
  ctx.beginPath();
  roundRect(ctx, -hw*0.82, labelTop, hw*1.64, labelH, 3);
  ctx.fill();
  // label stripes
  ctx.fillStyle='#c0392b';
  ctx.fillRect(-hw*0.82, labelTop, hw*1.64, labelH*0.28);
  ctx.fillStyle='#1a2e1a';
  ctx.fillRect(-hw*0.82, labelTop+labelH*0.28, hw*1.64, labelH*0.15);
  // label text lines
  ctx.fillStyle='rgba(0,0,0,0.3)';
  ctx.fillRect(-hw*0.55, labelTop + labelH*0.52, hw*1.1, 2);
  ctx.fillRect(-hw*0.4,  labelTop + labelH*0.68, hw*0.8, 2);

  // Highlight â€” capped at hh
  ctx.fillStyle='rgba(255,255,255,0.12)';
  ctx.fillRect(-hw+2, bodyTop+4, hw*0.4, hh - bodyTop - 8);

  // Outline
  ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.rect(-hw, bodyTop, d.w, hh*2); ctx.stroke();
}

// â”€â”€ CHUPITO (shot glass) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Small chunky shot glass, thick base, liquid inside
function drawChupito(ctx, d) {
  const hw = d.w/2, hh = d.h/2;
  const baseH = hh * 0.28;

  // Thick base
  ctx.beginPath();
  ctx.moveTo(-hw,  hh);
  ctx.lineTo( hw,  hh);
  ctx.lineTo( hw*0.88, hh - baseH);
  ctx.lineTo(-hw*0.88, hh - baseH);
  ctx.closePath();
  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fill();

  // Glass body (slight taper wider at top)
  ctx.beginPath();
  ctx.moveTo(-hw*0.78, -hh);
  ctx.lineTo( hw*0.78, -hh);
  ctx.lineTo( hw*0.88, hh - baseH);
  ctx.lineTo(-hw*0.88, hh - baseH);
  ctx.closePath();
  // Liquid fill â€” tequila gold
  const shotGrad = ctx.createLinearGradient(-hw, -hh, hw, 0);
  shotGrad.addColorStop(0, '#c8860a');
  shotGrad.addColorStop(0.5,'#f0b429');
  shotGrad.addColorStop(1, '#c8860a');
  ctx.fillStyle = shotGrad;
  ctx.fill();
  // glass tint overlay
  ctx.fillStyle='rgba(255,255,255,0.10)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.45)';
  ctx.lineWidth=1.5;
  ctx.stroke();

  // Liquid surface
  ctx.fillStyle='rgba(255,200,50,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, -hh+3, hw*0.68, 3, 0, 0, Math.PI*2);
  ctx.fill();

  // Highlight
  ctx.fillStyle='rgba(255,255,255,0.3)';
  ctx.beginPath();
  ctx.moveTo(-hw*0.68, -hh + 4);
  ctx.lineTo(-hw*0.42, -hh + 4);
  ctx.lineTo(-hw*0.52, hh - baseH - 4);
  ctx.lineTo(-hw*0.78, hh - baseH - 4);
  ctx.closePath();
  ctx.fill();
}

// â”€â”€ NEXT ITEM PREVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawNextPreview(ctx) {
  if (!nextItemDef) return;
  const d = nextItemDef;
  const px = W - 56, py = 90;

  ctx.save();
  // Panel background
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  roundRect(ctx, W - 88, 52, 76, 80, 6);
  ctx.fill(); ctx.stroke();

  // Label
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = "10px 'VT323', monospace";
  ctx.textAlign = 'center';
  ctx.fillText('NEXT', px, 68);

  // Draw item ghost at small scale
  ctx.translate(px, py + 4);
  const scale = Math.min(1, 44 / Math.max(d.w, d.h));
  ctx.scale(scale, scale);
  ctx.globalAlpha = 0.65;
  drawItem(ctx, d);
  ctx.restore();
  ctx.globalAlpha = 1;
}

// â”€â”€ ARM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawArm(ctx, handX, handY, baseX, baseY) {
  ctx.save();

  // â”€â”€ Forearm / sleeve â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Uses a bezier-based tapered shape for volume instead of flat trapezoid
  const sleeveW = 44;   // width at wrist
  const baseW   = 72;   // width at elbow (off-screen bottom)

  // Left edge of sleeve (slightly curved for roundness)
  const lWristX = handX - sleeveW / 2, lWristY = handY + 2;
  const rWristX = handX + sleeveW / 2, rWristY = handY + 2;
  const lBaseX  = baseX - baseW / 2,   lBaseY  = baseY;
  const rBaseX  = baseX + baseW / 2,   rBaseY  = baseY;

  // Sleeve shape with slight outward bow (rubber-hose volume)
  ctx.beginPath();
  ctx.moveTo(lWristX, lWristY);
  ctx.bezierCurveTo(lWristX - 10, handY + (baseY - handY) * 0.4,
                    lBaseX  - 6,  lBaseY  - (baseY - handY) * 0.3,
                    lBaseX, lBaseY);
  ctx.lineTo(rBaseX, rBaseY);
  ctx.bezierCurveTo(rBaseX  + 6,  rBaseY  - (baseY - handY) * 0.3,
                    rWristX + 10, handY + (baseY - handY) * 0.4,
                    rWristX, rWristY);
  ctx.closePath();

  // Sleeve gradient â€” dark navy with lighter inner highlight
  const sleeveGrad = ctx.createLinearGradient(handX - sleeveW, 0, handX + sleeveW, 0);
  sleeveGrad.addColorStop(0,   '#1a3060');
  sleeveGrad.addColorStop(0.3, '#2c5299');
  sleeveGrad.addColorStop(0.6, '#3a6abf');
  sleeveGrad.addColorStop(1,   '#1a3060');
  ctx.fillStyle = sleeveGrad;
  ctx.fill();

  // Sleeve centre highlight line (rubber-hose sheen)
  ctx.beginPath();
  ctx.moveTo(handX - 4, lWristY);
  ctx.bezierCurveTo(handX - 6, handY + (baseY - handY) * 0.35,
                    handX - 4, lBaseY - (baseY - handY) * 0.25,
                    handX - 3, lBaseY);
  ctx.strokeStyle = 'rgba(120,160,255,0.22)';
  ctx.lineWidth = 6;
  ctx.lineCap = 'round';
  ctx.stroke();

  // â”€â”€ Polsino (cuff) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const cuffW = sleeveW + 10, cuffH = 13;
  const cy = handY + 2;

  // Cuff base shape â€” slightly rounded rect
  ctx.beginPath();
  roundRect(ctx, handX - cuffW/2, cy - cuffH/2, cuffW, cuffH, 5);
  const cuffGrad = ctx.createLinearGradient(handX - cuffW/2, 0, handX + cuffW/2, 0);
  cuffGrad.addColorStop(0,   '#d4b896');
  cuffGrad.addColorStop(0.4, '#f0d9bc');
  cuffGrad.addColorStop(0.7, '#e8cba8');
  cuffGrad.addColorStop(1,   '#c9a47a');
  ctx.fillStyle = cuffGrad;
  ctx.fill();

  // Cuff stitching lines (two thin stripes)
  ctx.strokeStyle = 'rgba(160,110,60,0.35)';
  ctx.lineWidth = 0.8;
  for (const dy of [-2, 2]) {
    ctx.beginPath();
    ctx.moveTo(handX - cuffW/2 + 4, cy + dy);
    ctx.lineTo(handX + cuffW/2 - 4, cy + dy);
    ctx.stroke();
  }

  // Cuff button (small circle on right side)
  ctx.beginPath();
  ctx.arc(handX + cuffW/2 - 10, cy, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#a07848';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(handX + cuffW/2 - 10, cy, 3, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 0.8;
  ctx.stroke();

  ctx.restore(); // end cuff/sleeve ctx.save()

  // â”€â”€ Hand â€” cartoon Fleischer 3-finger style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.save();
  ctx.translate(handX, handY - 16);

  const OUTLINE_C = '#1a0800';
  const FILL_C    = '#e8b07a';
  const FILL_LIT  = '#f5cc95';
  const FILL_SHD  = '#c8784a';

  const paintFinger = (x1, y1, x2, y2, r) => {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    const nx = -dy/len, ny = dx/len;
    ctx.beginPath();
    ctx.arc(x2, y2, r, Math.atan2(dy, dx) - Math.PI/2, Math.atan2(dy, dx) + Math.PI/2);
    ctx.arc(x1, y1, r, Math.atan2(dy, dx) + Math.PI/2, Math.atan2(dy, dx) - Math.PI/2);
    ctx.closePath();
    ctx.fillStyle = FILL_C;
    ctx.fill();
    // Knuckle dent
    ctx.beginPath();
    ctx.arc(x1 + nx*r*0.3, y1 + ny*r*0.3, r*0.45, Math.PI*0.1, Math.PI*0.9);
    ctx.strokeStyle = FILL_SHD; ctx.lineWidth = 1.2; ctx.stroke();
  };

  // 3 fingers: index, middle (tallest), ring
  paintFinger(-12, 0,  -14, -24, 5);
  paintFinger(  1, -2,    0, -28, 5.5);
  paintFinger( 14,  0,   15, -23, 5);

  // Thumb â€” short, sticks out left
  paintFinger(-19, 10, -30,  -2, 5);

  // Palm background
  ctx.beginPath();
  ctx.ellipse(1, 6, 21, 15, 0, 0, Math.PI * 2);
  ctx.fillStyle = FILL_C;
  ctx.fill();

  // Re-draw fingers on top of palm (order fix)
  paintFinger(-12, 0,  -14, -24, 5);
  paintFinger(  1, -2,    0, -28, 5.5);
  paintFinger( 14,  0,   15, -23, 5);
  paintFinger(-19, 10, -30,  -2, 5);

  // Palm highlight
  ctx.beginPath();
  ctx.ellipse(-4, 3, 9, 6, -0.2, 0, Math.PI * 2);
  ctx.fillStyle = FILL_LIT; ctx.globalAlpha = 0.32; ctx.fill();
  ctx.globalAlpha = 1;

  ctx.restore();
}

// â”€â”€ ANCHOR TATTOO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawAnchorTattoo(ctx) {
  ctx.strokeStyle = 'rgba(30,10,60,0.88)';
  ctx.fillStyle   = 'rgba(30,10,60,0.65)';
  ctx.lineWidth   = 1.8;
  ctx.lineCap     = 'round';
  ctx.lineJoin    = 'round';
  const s = 0.52;
  ctx.scale(s, s);

  // Shaft
  ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, 20); ctx.stroke();

  // Ring at top
  ctx.beginPath(); ctx.arc(0, -20, 5.5, 0, Math.PI * 2); ctx.stroke();

  // Crossbar
  ctx.beginPath(); ctx.moveTo(-14, -7); ctx.lineTo(14, -7); ctx.stroke();
  // Crossbar end balls
  [-14, 14].forEach(x => {
    ctx.beginPath(); ctx.arc(x, -7, 2.5, 0, Math.PI*2);
    ctx.fill();
  });

  // Left fluke
  ctx.beginPath();
  ctx.moveTo(0, 20);
  ctx.bezierCurveTo(-3, 16, -18, 15, -18, 8);
  ctx.bezierCurveTo(-18, 3, -10, 5, -8, 12);
  ctx.stroke();

  // Right fluke
  ctx.beginPath();
  ctx.moveTo(0, 20);
  ctx.bezierCurveTo(3, 16, 18, 15, 18, 8);
  ctx.bezierCurveTo(18, 3, 10, 5, 8, 12);
  ctx.stroke();

  // Rope spiral (3 loops)
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(30,10,60,0.45)';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(0, -4 + i * 8, 4, -Math.PI * 0.65, Math.PI * 0.65);
    ctx.stroke();
  }
}

function drawTray(ctx) {
  if (!tray) return;
  const p = tray.position, a = tray.angle;
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(a);

  // Tray shadow
  ctx.fillStyle = 'rgba(0,0,0,.3)';
  ctx.beginPath();
  ctx.ellipse(4, TRAY_H/2 + 6, TRAY_W/2 + 6, 8, 0, 0, Math.PI*2);
  ctx.fill();

  // Tray body â€” rounded rectangle
  const tw = TRAY_W, th = TRAY_H;
  ctx.fillStyle = '#e8e0d0';
  roundRect(ctx, -tw/2, -th/2, tw, th, 5);
  ctx.fill();

  // Tray edge highlight
  ctx.fillStyle = '#f5f0e8';
  roundRect(ctx, -tw/2 + 2, -th/2 + 2, tw - 4, th/2 - 2, [3,3,0,0]);
  ctx.fill();

  // Tray dark edge
  ctx.fillStyle = '#a89880';
  roundRect(ctx, -tw/2, th/2 - 4, tw, 4, [0,0,5,5]);
  ctx.fill();

  // Cork mat texture
  ctx.fillStyle = 'rgba(120,80,40,.15)';
  for (let x = -tw/2 + 8; x < tw/2 - 8; x += 12) {
    ctx.beginPath();
    ctx.arc(x, 0, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
  if (typeof r === 'number') r = [r, r, r, r];
  ctx.beginPath();
  ctx.moveTo(x + r[0], y);
  ctx.lineTo(x + w - r[1], y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r[1]);
  ctx.lineTo(x+w, y+h-r[2]);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r[2], y+h);
  ctx.lineTo(x+r[3], y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r[3]);
  ctx.lineTo(x, y+r[0]);
  ctx.quadraticCurveTo(x, y, x+r[0], y);
  ctx.closePath();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SPAWNING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickRandomDef() {
  // At levels 4-5 (index 3-4): 30% chance of a hazard item
  if (currentLevelIdx >= 3 && Math.random() < 0.30) {
    return HAZARD_DEFS[Math.floor(Math.random() * HAZARD_DEFS.length)];
  }
  return ITEM_DEFS[Math.floor(Math.random() * ITEM_DEFS.length)];
}

function startSpawning() {
  // Spawn interval shrinks with level: 2800ms â†’ 1600ms by level 5
  const interval = Math.max(1600, 2800 - currentLevelIdx * 300);

  spawnItem();
  spawnedCount++;
  updateHUD();

  spawnTimer = setInterval(() => {
    if (isGameOver) { clearInterval(spawnTimer); return; }
    if (spawnedCount >= LEVELS[currentLevelIdx]) {
      clearInterval(spawnTimer);
      if (!isGameOver) beginWinCountdown();
      return;
    }
    spawnItem();
    spawnedCount++;
    updateHUD();
  }, interval);
}

function spawnItem() {
  const def = nextItemDef || pickRandomDef();
  nextItemDef = pickRandomDef();
  updateNextPreview();

  const sx = W / 2 + (Math.random() * 200 - 100);
  lastSpawnX = sx;

  // Bomb uses a circle body for realistic bouncing
  let body;
  const r = def.id === 'bomba' ? def.w / 2 : null;
  if (r) {
    body = Bodies.circle(sx, -def.h, r, {
      label: def.label,
      friction:      def.friction    ?? 0.85,
      frictionStatic:0.1,
      restitution:   def.restitution ?? 0.04,
      density:       def.density,
      render: { fillStyle: 'transparent' },
      collisionFilter: { category: 0x0002, mask: 0x0001 | 0x0002 }
    });
  } else {
    body = Bodies.rectangle(sx, -def.h, def.w, def.h, {
      label: def.label,
      friction:       def.friction    ?? 0.85,
      frictionStatic: def.friction    ?? 0.9,
      restitution:    def.restitution ?? 0.04,
      density:        def.density,
      render: { fillStyle: 'transparent' },
      collisionFilter: { category: 0x0002, mask: 0x0001 | 0x0002 }
    });
  }
  body._def     = def;
  body._landed  = false;
  body._bombLit = false;  // bomb fuse activated
  items.push(body);
  Composite.add(engine.world, body);

  const ind = document.getElementById('spawn-indicator');
  ind.style.left = Math.max(20, Math.min(W - 40, sx)) + 'px';
  ind.classList.add('show');
  setTimeout(() => ind.classList.remove('show'), 600);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  WIN COUNTDOWN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function beginWinCountdown() {
  if (isGameOver) return;
  isCountingDown = true;
  let sec = WIN_HOLD_SECS;

  const wrap = document.getElementById('countdown-wrap');
  const numEl = document.getElementById('countdown-num');
  const bar = document.getElementById('countdown-bar');

  wrap.style.display = 'flex';
  numEl.innerText = sec;
  bar.style.transition = 'none';
  bar.style.width = '100%';

  setTimeout(() => {
    bar.style.transition = `width ${WIN_HOLD_SECS - 0.1}s linear`;
    bar.style.width = '0%';
  }, 50);

  countTimer = setInterval(() => {
    if (isGameOver) { clearInterval(countTimer); wrap.style.display = 'none'; return; }
    sec--;
    numEl.innerText = sec;
    if (sec <= 0) {
      clearInterval(countTimer);
      wrap.style.display = 'none';
      levelComplete();
    }
  }, 1000);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LEVEL MESSAGES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LEVEL_PASS_MSGS = [
  ["Not badâ€¦", "â€¦for a trainee. ğŸ§‘â€ğŸ³"],
  ["The drinks survived.", "Unlike your dignity. ğŸ¹"],
  ["Impressive!", "Even the cocktail looks surprised. ğŸ¸"],
  ["Four levels down!", "The bar is literally raising itself. ğŸ”¥"],
];
const GAME_OVER_MSGS = [
  "The floor got thirsty.",
  "That's why we use plastic cups.",
  "The drinks filed a complaint.",
  "Sir, this is a bar, not a slip-n-slide.",
  "Bold strategy. Chaos, but bold.",
  "The mop is already on its way.",
  "You had one job. ONE.",
  "Gravity: 1 â€” You: 0.",
];

function levelComplete() {
  currentLevelIdx++;
  if (currentLevelIdx >= LEVELS.length) {
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('barbalance_best', bestScore);
    }
    document.getElementById('win-score').innerText = score;
    document.getElementById('win-best').innerText  = bestScore;
    document.getElementById('win-screen').style.display = 'flex';
  } else {
    // Ironic pass message before next level
    const msg = LEVEL_PASS_MSGS[Math.min(currentLevelIdx - 1, LEVEL_PASS_MSGS.length - 1)];
    showLevelQuip(msg[0], msg[1], () => {
      setupLevel();
    });
  }
}

function showLevelQuip(line1, line2, onDone) {
  const el = document.createElement('div');
  el.style.cssText = `
    position:absolute;inset:0;z-index:50;pointer-events:auto;
    background:rgba(0,0,0,0.82);
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px;
    font-family:'Bebas Neue',sans-serif;
    cursor:pointer;
  `;
  el.innerHTML = `
    <div style="font-size:clamp(28px,7vw,40px);color:#f0b429;letter-spacing:3px;
                text-shadow:0 0 20px #f0b42966;text-align:center;padding:0 20px">${line1}</div>
    <div style="font-size:clamp(22px,5.5vw,32px);color:#fff;letter-spacing:2px;
                text-align:center;padding:0 20px">${line2}</div>
    <div style="margin-top:24px;font-size:clamp(13px,3vw,17px);color:rgba(255,255,255,0.4);
                letter-spacing:2px;animation:blink 1s step-end infinite">TAP TO CONTINUE</div>
    <div style="margin-top:8px;font-size:clamp(16px,4vw,22px);color:#f0b429;letter-spacing:2px">
      LEVEL ${currentLevelIdx + 1} â†’</div>
  `;
  document.getElementById('game-wrap').appendChild(el);
  el.addEventListener('click', () => { el.remove(); onDone(); });
  // Auto-advance after 4s if no tap
  setTimeout(() => { if (el.parentNode) { el.remove(); onDone(); } }, 4000);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LOSE CONDITION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkLoseCondition() {
  for (const item of items) {
    const outSide = item.position.x < -100 || item.position.x > W + 100;
    const outBottom = item.position.y > H + 150;

    // If a lit bomb exits the play area â†’ defuse it (safe!)
    if (item._def && item._def.isBomb && item._bombLit && (outSide || outBottom)) {
      item._bombLit = false;
      // Cancel its timer
      bombTimers = bombTimers.filter(bt => {
        if (bt.body === item) { clearInterval(bt.interval); return false; }
        return true;
      });
    }

    if (outSide || outBottom) {
      if (!item._def.isBomb) { triggerGameOver(); return; } // normal item falls = lose
      // bomb fell off = safe, remove from items to stop tracking
    }
  }
  if (tray) {
    const absAngle = Math.abs(tray.angle) % (Math.PI * 2);
    const norm = absAngle > Math.PI ? Math.PI * 2 - absAngle : absAngle;
    const pct  = Math.min(1, norm / MAX_TRAY_ANGLE);

    // Tilt bar HUD
    const tiltEl = document.getElementById('tilt-disp');
    if (tiltEl) {
      const bar = 'â–ˆ'.repeat(Math.round(pct * 8)) + 'â–‘'.repeat(8 - Math.round(pct * 8));
      tiltEl.innerText = bar;
      tiltEl.style.color = pct > 0.7 ? '#e53e3e' : pct > 0.4 ? '#f0b429' : '#6ec87a';
    }

    // Danger vignette â€” lerps in when angle > 50% of limit
    const dangerPct = Math.max(0, (pct - 0.5) / 0.5);
    vignetteAlpha += (dangerPct * 0.35 - vignetteAlpha) * 0.08;

    if (norm > MAX_TRAY_ANGLE) { triggerGameOver(); return; }

    const warn = document.getElementById('tilt-warn');
    if (norm > MAX_TRAY_ANGLE * 0.72) {
      warn.classList.add('show');
      warn.style.left = (tray.angle > 0 ? '60%' : '20%');
    } else {
      warn.classList.remove('show');
    }
  }
}

function triggerGameOver() {
  if (isGameOver) return;
  isGameOver = true;
  isCountingDown = false;
  clearInterval(spawnTimer);
  clearInterval(countTimer);
  vignetteAlpha = 0;
  document.getElementById('tilt-warn').classList.remove('show');
  document.getElementById('countdown-wrap').style.display = 'none';

  // Save best score
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('barbalance_best', bestScore);
  }

  // Populate game-over screen
  document.getElementById('go-level').innerText = currentLevelIdx + 1;
  document.getElementById('go-score').innerText = score;
  document.getElementById('go-best').innerText = bestScore;
  // Random ironic quip
  const quip = GAME_OVER_MSGS[Math.floor(Math.random() * GAME_OVER_MSGS.length)];
  const quipEl = document.getElementById('go-quip');
  if (quipEl) quipEl.innerText = '"' + quip + '"';
  // Item summary: count per type
  const counts = {};
  landedItems.forEach(d => { counts[d.label] = (counts[d.label] || 0) + 1; });
  const summaryEl = document.getElementById('go-items');
  if (summaryEl) {
    summaryEl.innerHTML = Object.entries(counts)
      .map(([name, n]) => `<span>${n}Ã— ${name}</span>`)
      .join('&nbsp; ');
  }

  document.getElementById('gameover-screen').style.display = 'flex';

  // Screen shake
  const wrap = document.getElementById('game-wrap');
  wrap.style.animation = 'none';
  const s = document.createElement('style');
  s.innerText = '@keyframes shake{0%,100%{transform:translateX(0)}20%{transform:translateX(-8px)}40%{transform:translateX(8px)}60%{transform:translateX(-6px)}80%{transform:translateX(6px)}}';
  document.head.appendChild(s);
  wrap.style.animation = 'shake .5s ease';
  setTimeout(() => wrap.style.animation = '', 500);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  HUD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHUD() {
  document.getElementById('lvl-disp').innerText   = 'LV ' + (currentLevelIdx + 1);
  document.getElementById('items-disp').innerText = spawnedCount + ' / ' + LEVELS[currentLevelIdx];
  document.getElementById('score-disp').innerText = score;
  const bestEl = document.getElementById('best-disp');
  if (bestEl) bestEl.innerText = 'â˜… ' + bestScore;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GAME FLOW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showTutorial() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('tutorial-screen').style.display = 'flex';
}

function startGame() {
  document.getElementById('tutorial-screen').style.display = 'none';
  document.getElementById('start-screen').style.display = 'none';
  // Preload background PNG
  if (!window._bgImg) {
    window._bgImg = new Image();
    window._bgImg.src = './ASSET/BarBahlance_mainScreen.png';
  }
  initEngine();
  setupLevel();
}

function fullReset() {
  // Stop engine
  if (runner) Runner.stop(runner);
  if (render) Render.stop(render);
  // Reset all state
  currentLevelIdx = 0;
  score = 0;
  landedItems = [];
  particles = [];
  floatingTexts.length = 0;
  isGameOver = false;
  // Hide all game screens
  document.getElementById('win-screen').style.display       = 'none';
  document.getElementById('gameover-screen').style.display  = 'none';
  document.getElementById('hud').style.display              = 'none';
  document.getElementById('score-bar').style.display        = 'none';
  document.getElementById('countdown-wrap').style.display   = 'none';
  document.getElementById('tilt-warn').classList.remove('show');
  // Remove any canvas
  const old = document.getElementById('game-wrap').querySelector('canvas');
  if (old) old.remove();
  // Back to cover
  document.getElementById('start-screen').style.display = 'flex';
  document.getElementById('tutorial-screen').style.display = 'none';
}

function resetGame() {
  currentLevelIdx = 0;
  smoothX = W / 2;
  score = 0;
  landedItems = [];
  document.getElementById('gameover-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
  setupLevel();
}
</script>
</body>
</html>
