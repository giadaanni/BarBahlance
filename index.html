<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bar Bahlance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
        }

        #game-container {
            position: relative;
            width: 100vh;
            max-width: 100%;
            aspect-ratio: 2/3;
            background-color: #4a3b59;
            overflow: hidden;
            border: 4px solid #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        #start-screen {
            background: url('./ASSET/BarBahlance_mainScreen.png') no-repeat center center;
            background-size: cover;
            pointer-events: auto;
            cursor: pointer;
            z-index: 20; /* Sopra a tutto */
        }

        .blink-text {
            margin-top: 60%;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            font-size: 20px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* HUD nascosto di default */
        #hud {
            display: none; 
            justify-content: flex-start;
            padding-top: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 14px;
        }

        #countdown {
            font-size: 40px;
            color: yellow;
            display: none;
        }

        #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            display: none;
            pointer-events: auto;
            z-index: 30;
        }

        .btn {
            background: #ffcc00;
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="start-screen" class="ui-layer" onclick="startGame()">
        <div class="blink-text">TAP TO START</div>
    </div>

    <div id="hud" class="ui-layer">
        <div id="level-display">LEVEL 1</div>
        <div id="items-display">Items: 0/3</div>
        <div id="countdown"></div>
    </div>

    <div id="game-over-screen" class="ui-layer">
        <h1 style="color: red; text-shadow: 3px 3px 0 #000;">CRASH!</h1>
        <p style="color: white;">You dropped a drink!</p>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>
</div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body;

    const LEVELS = [3, 5, 7, 10, 12];
    let engine, render, runner, tray;
    let items = [];
    let currentLevelIdx = 0, itemsToSpawn = 0, spawnedCount = 0;
    let isGameOver = false, countdownTimer = null, spawnInterval = null;
    
    const width = 600, height = 900;

    function init() {
        engine = Engine.create();
        // Stabilizzazione fisica per evitare tremolii
        engine.positionIterations = 10;
        engine.velocityIterations = 10;

        const container = document.getElementById('game-container');
        const oldCanvas = container.querySelector('canvas');
        if(oldCanvas) oldCanvas.remove();

        render = Render.create({
            element: container,
            engine: engine,
            options: { width: width, height: height, wireframes: false, background: 'transparent' }
        });

        runner = Runner.create();
        render.canvas.addEventListener('mousemove', handleInput);
        render.canvas.addEventListener('touchmove', handleInput, {passive: false});

        Events.on(render, 'afterRender', function() {
            drawHand();
            checkLoseCondition();
        });
    }

    function setupLevel() {
        Composite.clear(engine.world);
        Engine.clear(engine);
        items = [];
        isGameOver = false;
        
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('level-display').innerText = `LEVEL ${currentLevelIdx + 1}`;
        document.getElementById('items-display').innerText = `Next: ${LEVELS[currentLevelIdx]}`;
        document.getElementById('countdown').style.display = 'none';
        
        tray = Bodies.rectangle(width / 2, height - 200, 350, 20, { 
            isStatic: true, 
            render: { fillStyle: '#C0C0C0' },
            friction: 0.15,
            slop: 0.5 // Aiuta a ridurre le micro-collisioni
        });

        Composite.add(engine.world, tray);
        Render.run(render);
        Runner.run(runner, engine);

        itemsToSpawn = LEVELS[currentLevelIdx];
        spawnedCount = 0;
        startSpawning();
    }

    function handleInput(e) {
        if (isGameOver) return;
        e.preventDefault();
        let clientX = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        const rect = render.canvas.getBoundingClientRect();
        const scaleX = width / rect.width;
        const x = (clientX - rect.left) * scaleX;

        const maxAngle = 60 * (Math.PI / 180); 
        const normalizedX = (x - width / 2) / (width / 2); 
        let targetAngle = Math.max(Math.min(normalizedX * maxAngle, maxAngle), -maxAngle);

        const currentAngle = tray.angle;
        const smoothFactor = 0.12; 
        Body.setAngle(tray, currentAngle + (targetAngle - currentAngle) * smoothFactor);
    }

    function drawHand() {
        const ctx = render.context;
        const trayPos = tray.position;
        ctx.beginPath();
        ctx.moveTo(width / 2, height); 
        ctx.lineTo(trayPos.x, trayPos.y); 
        ctx.lineWidth = 40;
        ctx.strokeStyle = '#e0ac69'; 
        ctx.lineCap = 'round';
        ctx.stroke();
    }

    function startSpawning() {
        spawnInterval = setInterval(() => {
            if (isGameOver) { clearInterval(spawnInterval); return; }
            if (spawnedCount >= itemsToSpawn) {
                clearInterval(spawnInterval);
                checkWinCondition(); 
                return;
            }
            spawnItem();
            spawnedCount++;
            document.getElementById('items-display').innerText = `Items: ${spawnedCount}/${itemsToSpawn}`;
        }, 2200);
    }

    function spawnItem() {
        const startX = (width / 2) + (Math.random() * 320 - 160); 
        const itemType = Math.floor(Math.random() * 5);
        let item;
        const commonProps = { 
            friction: 0.15, 
            frictionAir: 0.01, // Attrito dell'aria per stabilizzare la caduta
            restitution: 0.05, // Quasi nessun rimbalzo per evitare tremolii
            render: { strokeStyle: '#000', lineWidth: 2 } 
        };

        switch(itemType) {
            case 0: // Boccale iconico
                const mugBody = Bodies.rectangle(startX, -50, 50, 70, { render: { fillStyle: '#f28e1c' } });
                const mugHandle = Bodies.rectangle(startX + 30, -50, 12, 35, { render: { fillStyle: '#e5e5e5' } });
                item = Body.create({ parts: [mugBody, mugHandle], density: 0.005, ...commonProps });
                break;
            case 1: // Bottiglia rifinita
                const botNeck = Bodies.rectangle(startX, -95, 12, 35, { render: { fillStyle: '#1e5d3c' } });
                const botBody = Bodies.rectangle(startX, -55, 35, 65, { render: { fillStyle: '#2e8b57' } });
                item = Body.create({ parts: [botNeck, botBody], density: 0.0045, ...commonProps });
                break;
            case 2: // Calice (Corretto: Coppa trapezoidale + stelo + base)
                const cup = Bodies.trapezoid(startX, -85, 50, 40, 0.5, { render: { fillStyle: '#900020' } });
                const stem = Bodies.rectangle(startX, -55, 6, 30, { render: { fillStyle: '#eee' } });
                const base = Bodies.rectangle(startX, -40, 35, 6, { render: { fillStyle: '#eee' } });
                item = Body.create({ parts: [cup, stem, base], density: 0.0035, ...commonProps });
                break;
            case 3: // Shot
                item = Bodies.rectangle(startX, -50, 25, 35, { render: { fillStyle: '#ADD8E6' }, density: 0.004, ...commonProps });
                break;
            case 4: // Drink Largo
                const glass = Bodies.rectangle(startX, -50, 50, 60, { render: { fillStyle: '#ff69b4' } });
                const liquid = Bodies.rectangle(startX, -55, 40, 40, { render: { fillStyle: '#ff1493' } });
                item = Body.create({ parts: [glass, liquid], density: 0.004, ...commonProps });
                break;
        }
        items.push(item);
        Composite.add(engine.world, item);
    }

    function checkLoseCondition() {
        if (isGameOver) return;
        items.forEach(item => { if (item.position.y > height + 60) gameOver(); });
    }

    function checkWinCondition() {
        let timeLeft = 8;
        const countEl = document.getElementById('countdown');
        countEl.style.display = 'block';
        countEl.innerText = timeLeft;
        countdownTimer = setInterval(() => {
            if (isGameOver) { clearInterval(countdownTimer); return; }
            timeLeft--;
            countEl.innerText = timeLeft;
            if (timeLeft <= 0) { clearInterval(countdownTimer); levelComplete(); }
        }, 1000);
    }

    function levelComplete() {
        if (currentLevelIdx < LEVELS.length - 1) {
            currentLevelIdx++;
            alert("LEVEL COMPLETE!");
            setupLevel(); 
        } else {
            alert("BAR MASTER!");
            resetGame();
        }
    }

    function gameOver() {
        isGameOver = true;
        clearInterval(spawnInterval);
        clearInterval(countdownTimer);
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        init();
        setupLevel();
    }

    function resetGame() {
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        currentLevelIdx = 0;
    }
</script>
</body>
</html>
