<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BarBalance</title>
  <style>
    :root { --bg:#0f1115; --text:#e8e8e8; --muted:#aeb6c7; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;height:100%;}
    #stage{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden;}
    canvas{display:block;touch-action:none;-webkit-user-select:none;user-select:none;border-radius:18px;background:#121625;}
    #hud{
      position:fixed;
      left:max(10px, env(safe-area-inset-left));
      right:max(10px, env(safe-area-inset-right));
      top:max(10px, env(safe-area-inset-top));
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      pointer-events:none;
      z-index:5;
    }
    .pill{
      pointer-events:auto;
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px;padding:8px 12px;font-size:13px;
      display:flex;gap:10px;align-items:center;white-space:nowrap;
      backdrop-filter: blur(8px);
    }
    button{pointer-events:auto;border:0;border-radius:999px;padding:8px 12px;background:#2b3350;color:#fff;font-weight:700;}
    button:active{transform:scale(.99)}
    #hint{
      position:fixed;left:50%;transform:translateX(-50%);
      bottom:max(12px, env(safe-area-inset-bottom));
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;padding:10px 12px;font-size:13px;color:var(--muted);
      pointer-events:none;
      max-width:min(520px, calc(100vw - 24px));
      text-align:center;
      backdrop-filter: blur(8px);
      z-index:5;
    }
    #overlay{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      z-index:10;
    }
    #overlay .card{
      background:rgba(20,24,36,.96);
      border:1px solid rgba(255,255,255,.10);
      border-radius:20px;
      padding:18px 18px 16px;
      text-align:center;
      width:min(330px, calc(100vw - 40px));
    }
    #overlay .title{font-size:22px; font-weight:800; margin:0 0 6px;}
    #overlay .sub{font-size:13px; color:var(--muted); margin:0 0 12px;}
    #overlay .btnRow{display:flex; gap:10px; justify-content:center;}
  </style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>

  <div id="hud">
    <div class="pill">
      <span id="score">Score: 0</span>
      <span style="opacity:.6">•</span>
      <span id="items">Items: 0/10</span>
    </div>
    <div class="pill">
      <span id="state">OK</span>
      <button id="restart">Restart</button>
    </div>
  </div>

  <div id="hint">Trascina a sinistra/destra per ruotare il polso. Se un oggetto esce dal vassoio: game over.</div>

  <div id="overlay">
    <div class="card">
      <p class="title">GAME OVER</p>
      <p class="sub" id="reason">Un oggetto è uscito dal vassoio.</p>
      <div class="btnRow">
        <button id="restart2">Restart</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
  (() => {
    const { Engine, World, Bodies, Body, Composite, Events } = Matter;

    // ---- Canvas 2:3 fit ----
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function getViewport() {
      const h = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
      const w = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
      return { w, h };
    }

    const RATIO_W = 2, RATIO_H = 3;
    const WORLD_W = 900, WORLD_H = 1350;

    let cw=0, ch=0, dpr=1;

    function resizeCanvas() {
      const { w, h } = getViewport();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const targetH = Math.min(h, w * (RATIO_H / RATIO_W));
      const targetW = targetH * (RATIO_W / RATIO_H);
      cw = Math.floor(targetW);
      ch = Math.floor(targetH);
      canvas.style.width = cw + "px";
      canvas.style.height = ch + "px";
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas, { passive:true });
    resizeCanvas();

    function worldToScreen() {
      const s = Math.min(cw / WORLD_W, ch / WORLD_H);
      const ox = (cw - WORLD_W * s) / 2;
      const oy = (ch - WORLD_H * s) / 2;
      return { s, ox, oy };
    }

    // ---- HUD ----
    const scoreEl = document.getElementById('score');
    const itemsEl = document.getElementById('items');
    const stateEl = document.getElementById('state');
    const restartBtn = document.getElementById('restart');
    const restartBtn2 = document.getElementById('restart2');
    const hintEl = document.getElementById('hint');
    const overlayEl = document.getElementById('overlay');
    const reasonEl = document.getElementById('reason');

    function setState(s){ stateEl.textContent = s; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // ---- Physics ----
    const engine = Engine.create({ enableSleeping: true });
    engine.gravity.y = 1.0;
    engine.positionIterations = 12;
    engine.velocityIterations = 10;
    const world = engine.world;

    const wallThickness = 180;
    World.add(world, [
      Bodies.rectangle(-wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 800, { isStatic:true }),
      Bodies.rectangle(WORLD_W + wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 800, { isStatic:true }),
      Bodies.rectangle(WORLD_W/2, WORLD_H + wallThickness/2, WORLD_W + 800, wallThickness, { isStatic:true })
    ]);

    // ---- Tray ----
    const wrist = { x: WORLD_W*0.5, y: WORLD_H*0.68 };
    const TRAY_LEN = 640;
    const TRAY_THK = 34;

    function makeTray(x,y){
      const plank = Bodies.rectangle(x, y, TRAY_LEN, TRAY_THK, { chamfer:{ radius:12 } });
      const lipL  = Bodies.rectangle(x - TRAY_LEN/2 + 14, y - 10, 22, 30, { chamfer:{ radius:6 } });
      const lipR  = Bodies.rectangle(x + TRAY_LEN/2 - 14, y - 10, 22, 30, { chamfer:{ radius:6 } });
      return Body.create({
        parts: [plank, lipL, lipR],
        friction: 1.0,
        frictionStatic: 1.25,
        restitution: 0.02,
        density: 0.0042,
        inertia: Infinity,
        label: "tray"
      });
    }

    const trayHome = { x: wrist.x, y: wrist.y - 110 };
    const tray = makeTray(trayHome.x, trayHome.y);
    World.add(world, tray);

    // Sensor: thin rectangle slightly ABOVE the tray plane (follows tray angle)
    const traySensor = Bodies.rectangle(trayHome.x, trayHome.y - 22, TRAY_LEN - 20, 26, {
      isStatic: true,
      isSensor: true,
      label: "traySensor"
    });
    World.add(world, traySensor);

    Body.setPosition(tray, trayHome);
    Body.setVelocity(tray, { x: 0, y: 0 });
    Body.setAngle(tray, 0);
    Body.setAngularVelocity(tray, 0);

    // ---- Control ----
    let targetAngle = 0;
    const MAX_ANGLE = 0.36;
    const SENS = 2.0;
    let dragging=false, lastX=0;

    function getPointerX(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      return (clientX - rect.left) / rect.width;
    }

    function onDown(e){ dragging=true; lastX=getPointerX(e); hintEl.style.opacity=0; }
    function onMove(e){
      if(!dragging) return;
      const x=getPointerX(e);
      const dx=x-lastX; lastX=x;
      targetAngle = clamp(targetAngle + dx*SENS, -MAX_ANGLE, +MAX_ANGLE);
    }
    function onUp(){ dragging=false; }

    canvas.addEventListener('pointerdown', (e)=>{ canvas.setPointerCapture(e.pointerId); onDown(e); }, { passive:true });
    canvas.addEventListener('pointermove', (e)=>onMove(e), { passive:true });
    canvas.addEventListener('pointerup', onUp, { passive:true });
    canvas.addEventListener('pointercancel', onUp, { passive:true });
    canvas.addEventListener('touchstart', onDown, { passive:true });
    canvas.addEventListener('touchmove', onMove, { passive:true });
    canvas.addEventListener('touchend', onUp, { passive:true });

    function controlTray(dt){
      const follow = 1 - Math.exp(-18 * dt);
      const newAngle = tray.angle + (targetAngle - tray.angle) * follow;
      const angVel = (newAngle - tray.angle) / dt;

      Body.setAngle(tray, newAngle);
      Body.setAngularVelocity(tray, clamp(angVel, -3.2, 3.2));
      Body.setPosition(tray, trayHome);
      Body.setVelocity(tray, { x: 0, y: 0 });

      // keep sensor aligned with tray
      Body.setAngle(traySensor, tray.angle);
      Body.setPosition(traySensor, { x: trayHome.x, y: trayHome.y - 22 });
    }

    // ---- Game state ----
    const MAX_ITEMS = 10;
    let alive=true, score=0, t=0;
    let spawnEvery=2.8, nextSpawn=2.8;

    const droplets=[];
    function addDroplet(x,y,vx,vy,color){ droplets.push({x,y,vx,vy,color,life:1.0}); }

    function countItems(){
      const bodies = Composite.allBodies(world);
      let n=0;
      for (const b of bodies) {
        if (b.label==="tray" || b.label==="traySensor" || b.isStatic) continue;
        n++;
      }
      return n;
    }

    // ---- Objects ----
    function makeTumbler(x,y){
      const shell = Bodies.rectangle(x, y-16, 72, 76, { chamfer:{radius:10} });
      const base  = Bodies.rectangle(x, y+22, 58, 20, { chamfer:{radius:8} });
      const cup = Body.create({
        parts:[shell, base],
        friction: 0.95, restitution:0.01, density:0.0033, label:"tumbler"
      });
      cup.plugin = { liquid: { fill:0.78, slosh:0, color:"#6bdcff" } };
      return cup;
    }

    function makeBottle(x,y){
      const body = Bodies.rectangle(x, y+20, 60, 120, { chamfer:{radius:12} });
      const shoulder = Bodies.rectangle(x, y-30, 52, 30, { chamfer:{radius:10} });
      const neck = Bodies.rectangle(x, y-64, 28, 52, { chamfer:{radius:10} });
      const cap  = Bodies.rectangle(x, y-96, 34, 16, { chamfer:{radius:6} });
      return Body.create({
        parts:[body, shoulder, neck, cap],
        friction: 0.72, restitution:0.01, density:0.0040, label:"bottle"
      });
    }

    function makeWineGlass(x,y){
      const bowl = Bodies.rectangle(x, y-40, 82, 70, { chamfer:{radius:18} });
      const stem = Bodies.rectangle(x, y+20, 16, 60, { chamfer:{radius:6} });
      const base = Bodies.rectangle(x, y+66, 84, 18, { chamfer:{radius:10} });
      const g = Body.create({
        parts:[bowl, stem, base],
        friction: 0.62, restitution:0.01, density:0.0030, label:"wine"
      });
      g.plugin = { liquid: { fill:0.62, slosh:0, color:"#ff7a59" } };
      return g;
    }

    function spawnOne(){
      const x = WORLD_W * (0.24 + Math.random()*0.52);
      const y = WORLD_H * 0.08;

      const r = Math.random();
      let body;
      if (r < 0.45) body = makeTumbler(x,y);
      else if (r < 0.78) body = makeWineGlass(x,y);
      else body = makeBottle(x,y);

      body.plugin = body.plugin || {};
      body.plugin.touchedTray = false;   // becomes true on sensor collision
      body.plugin.spawnedAt = t;

      Body.setAngle(body, (Math.random()*0.14 - 0.07));
      World.add(world, body);
    }

    function maybeSpawn(){
      if (!alive) return;
      if (countItems() >= MAX_ITEMS) return;
      if (t < nextSpawn) return;

      const difficulty = Math.min(1, t/240);
      spawnEvery = Math.max(2.0, spawnEvery * (0.997 - 0.0010*difficulty));
      nextSpawn = t + spawnEvery;

      spawnOne();
    }

    // Mark touchedTray using sensor collisions
    Events.on(engine, "collisionStart", (evt) => {
      for (const pair of evt.pairs) {
        const a = pair.bodyA;
        const b = pair.bodyB;

        let obj = null;
        if (a.label === "traySensor" && !b.isStatic && b.label !== "tray") obj = b;
        if (b.label === "traySensor" && !a.isStatic && a.label !== "tray") obj = a;

        if (obj) {
          obj.plugin = obj.plugin || {};
          obj.plugin.touchedTray = true;
        }
      }
    });

    // ---- Liquids ----
    function updateLiquids(dt){
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (!b.plugin || !b.plugin.liquid) continue;
        const liq = b.plugin.liquid;

        const targetSlosh = clamp((-b.angularVelocity*0.7) + (tray.angle*0.7), -0.75, 0.75);
        liq.slosh += (targetSlosh - liq.slosh) * (1 - Math.exp(-7*dt));

        const spillThresh = 0.52 - (liq.fill * 0.18);
        if (Math.abs(liq.slosh) > spillThresh && liq.fill > 0.08) {
          const spillRate = (Math.abs(liq.slosh) - spillThresh) * 0.16;
          liq.fill = Math.max(0, liq.fill - spillRate * dt);

          if (Math.random() < 0.14) {
            addDroplet(b.position.x + (Math.random()*18-9), b.position.y - 70,
                      (Math.random()*60-30), 60 + Math.random()*70, liq.color);
          }
        }
      }

      for (let i=droplets.length-1;i>=0;i--){
        const d = droplets[i];
        d.vy += 260*dt;
        d.x += d.vx*dt;
        d.y += d.vy*dt;
        d.life -= dt;
        if (d.life<=0 || d.y > WORLD_H+140) droplets.splice(i,1);
      }
    }

    // ---- Robust "off tray" test using lowest vertex along tray normal ----
    function getSupportVMin(body, cos, sin){
      // v = -dx*sin + dy*cos in tray frame. We want the minimum v among vertices (lowest relative to tray).
      let vmin = Infinity;
      for (const p of body.vertices) {
        const dx = p.x - tray.position.x;
        const dy = p.y - tray.position.y;
        const v = -dx * sin + dy * cos;
        if (v < vmin) vmin = v;
      }
      return vmin;
    }

    function isOnTray(body){
      body.plugin = body.plugin || {};

      // Never lose during the first ~0.45s: avoids rare spawn/solver spikes
      if ((t - (body.plugin.spawnedAt || 0)) < 0.45) return true;

      // If it never touched the tray sensor:
      // - while it's still above sensor height -> it's falling, don't judge
      // - if it passes BELOW the tray without touching -> it missed the tray -> lose
      if (!body.plugin.touchedTray) {
        if (body.bounds.max.y < traySensor.position.y - 40) return true;
        if (body.bounds.min.y > tray.position.y + 140) return false; // missed the tray entirely
        return true;
      }

      // Now it has touched: apply footprint test
      const cos = Math.cos(tray.angle), sin = Math.sin(tray.angle);

      // Use body center for u (lateral) and lowest vertex for v (vertical relative to tray)
      const dxC = body.position.x - tray.position.x;
      const dyC = body.position.y - tray.position.y;
      const u = dxC * cos + dyC * sin;

      const halfLen = TRAY_LEN * 0.5;
      const uTol = halfLen - 10;

      if (u < -uTol || u > uTol) return false;

      const vMin = getSupportVMin(body, cos, sin);
      const vTolBelow = 52; // generous: prevents false lose when tray is tilted and object settles

      // if the lowest point is clearly below tray plane -> fell off
      if (vMin < -vTolBelow) return false;

      return true;
    }

    function gameOver(reason){
      alive = false;
      setState("GAME OVER");
      reasonEl.textContent = reason || "Un oggetto è uscito dal vassoio.";
      overlayEl.style.display = "flex";
    }

    function checkLose(){
      if (!alive) return;
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label==="tray" || b.label==="traySensor" || b.isStatic) continue;
        if (!isOnTray(b)) {
          const r = (b.plugin && b.plugin.touchedTray) ? "Un oggetto è uscito dal vassoio." : "Un oggetto ha mancato il vassoio.";
          gameOver(r);
          return;
        }
      }
    }

    function reset(){
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label==="tray" || b.label==="traySensor" || b.isStatic) continue;
        World.remove(world, b);
      }
      droplets.length = 0;

      alive=true;
      score=0;
      t=0;
      spawnEvery=2.8;
      nextSpawn=2.8;
      targetAngle=0;

      Body.setAngle(tray, 0);
      Body.setAngularVelocity(tray, 0);
      Body.setPosition(tray, trayHome);
      Body.setVelocity(tray, {x:0,y:0});

      Body.setAngle(traySensor, 0);
      Body.setPosition(traySensor, { x: trayHome.x, y: trayHome.y - 22 });

      overlayEl.style.display = "none";
      hintEl.style.opacity = 1;
      setState("OK");
    }
    restartBtn.addEventListener('click', reset);
    restartBtn2.addEventListener('click', reset);

    // ---- Rendering ----
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawBackground(){
      const { s, ox, oy } = worldToScreen();
      ctx.save();
      ctx.translate(ox, oy);
      ctx.fillStyle = "#121625";
      ctx.fillRect(0,0, WORLD_W*s, WORLD_H*s);

      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = "#9aa3b2";
      ctx.lineWidth = 1;
      const step = 90*s;
      for (let x=0; x<=WORLD_W*s; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_H*s); ctx.stroke(); }
      for (let y=0; y<=WORLD_H*s; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W*s,y); ctx.stroke(); }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawArmAndHand(){
      const { s, ox, oy } = worldToScreen();
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      ctx.save();
      ctx.translate(wrist.x, wrist.y + 250);
      ctx.rotate(-0.15);
      ctx.fillStyle = "#b28b68";
      roundRect(ctx, -120, -40, 240, 580, 90);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(wrist.x, wrist.y + 50);
      ctx.rotate(tray.angle * 0.95);
      ctx.fillStyle = "#caa07a";
      roundRect(ctx, -175, -52, 350, 104, 52);
      ctx.fill();

      ctx.fillStyle = "#d3ac86";
      for (let i=0;i<4;i++){
        roundRect(ctx, -155 + i*78, -102, 62, 58, 22);
        ctx.fill();
      }
      ctx.restore();

      ctx.restore();
    }

    function pathVertices(verts){
      ctx.beginPath();
      ctx.moveTo(verts[0].x, verts[0].y);
      for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
      ctx.closePath();
    }

    function drawLiquid(b){
      const liq = b.plugin.liquid;
      const bounds = b.bounds;
      const h = (bounds.max.y - bounds.min.y);
      const levelY = bounds.max.y - h * liq.fill;
      const tilt = liq.slosh;
      const cx = (bounds.min.x + bounds.max.x) * 0.5;

      const y2 = levelY + tilt * (bounds.max.x - cx) * 0.9;
      const y1 = levelY + tilt * (bounds.min.x - cx) * 0.9;

      ctx.fillStyle = liq.color;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 140, bounds.max.y + 140);
      ctx.lineTo(bounds.max.x + 140, bounds.max.y + 140);
      ctx.lineTo(bounds.max.x + 140, y2);
      ctx.lineTo(bounds.min.x - 140, y1);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 70, y1);
      ctx.lineTo(bounds.max.x + 70, y2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawBodies(){
      const { s, ox, oy } = worldToScreen();
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      const bodies = Composite.allBodies(world);

      // tray
      ctx.save();
      ctx.translate(tray.position.x, tray.position.y);
      ctx.rotate(tray.angle);

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      roundRect(ctx, -330, -10, 660, 38, 18);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#3b4258";
      roundRect(ctx, -320, -18, 640, 34, 16);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 3;
      roundRect(ctx, -312, -14, 624, 26, 14);
      ctx.stroke();

      ctx.restore();

      // items
      for (const b of bodies) {
        if (b.label==="tray" || b.label==="traySensor" || b.isStatic) continue;

        let fill = "#d8e2ff";
        if (b.label==="tumbler") fill = "#cfd8ff";
        if (b.label==="wine") fill = "#d8e2ff";
        if (b.label==="bottle") fill = "#7de0b8";

        if (b.plugin && b.plugin.liquid) {
          pathVertices(b.vertices);
          ctx.save();
          ctx.clip();
          drawLiquid(b);
          ctx.restore();
        }

        ctx.fillStyle = fill;
        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 2;
        pathVertices(b.vertices);
        ctx.fill();
        ctx.stroke();
      }

      // droplets
      for (const d of droplets) {
        ctx.globalAlpha = Math.max(0, Math.min(1, d.life));
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(d.x, d.y, 4.3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    // ---- Main loop ----
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (alive) {
        t += dt;
        maybeSpawn();
        score += dt * (2 + 0.22 * countItems());
      }

      controlTray(dt);
      Engine.update(engine, dt * 1000);
      updateLiquids(dt);
      checkLose();

      drawBackground();
      drawArmAndHand();
      drawBodies();

      scoreEl.textContent = `Score: ${Math.floor(score)}`;
      itemsEl.textContent = `Items: ${countItems()}/${MAX_ITEMS}`;

      requestAnimationFrame(tick);
    }

    reset();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
