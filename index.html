<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bar Bahlance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Press Start 2P', cursive; }
        #game-container { position: relative; width: 100vh; max-width: 100%; aspect-ratio: 2/3; background-color: #3d2e4d; border: 4px solid #000; }
        canvas { display: block; width: 100%; height: 100%; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        #start-screen { background: url('./ASSET/BarBahlance_mainScreen.png') no-repeat center center; background-size: cover; pointer-events: auto; cursor: pointer; z-index: 20; }
        .blink-text { margin-top: 60%; color: #fff; text-shadow: 4px 4px 0 #000; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        #hud { display: none; justify-content: flex-start; padding-top: 20px; color: white; font-size: 14px; }
        #countdown { font-size: 40px; color: yellow; display: none; margin-top: 20px; }
        #game-over-screen { background: rgba(0, 0, 0, 0.85); display: none; pointer-events: auto; z-index: 30; }
        .btn { background: #ffcc00; border: 4px solid #fff; padding: 15px 30px; font-family: 'Press Start 2P', cursive; cursor: pointer; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="start-screen" class="ui-layer" onclick="startGame()">
        <div class="blink-text">TAP TO START</div>
    </div>
    <div id="hud" class="ui-layer">
        <div id="level-display">LEVEL 1</div>
        <div id="items-display">Items: 0/3</div>
        <div id="countdown">8</div>
    </div>
    <div id="game-over-screen" class="ui-layer">
        <h1 style="color: red;">CRASH!</h1>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Body, Constraint } = Matter;

    const LEVELS = [3, 5, 7, 10, 12];
    let engine, render, runner, tray, mouseConstraint;
    let items = [], currentLevelIdx = 0, spawnedCount = 0, isGameOver = false;
    const width = 600, height = 900;
    let targetX = width / 2;

    function init() {
        engine = Engine.create();
        engine.constraintIterations = 5; // Più precisione per il perno

        const container = document.getElementById('game-container');
        render = Render.create({
            element: container,
            engine: engine,
            options: { width: width, height: height, wireframes: false, background: 'transparent' }
        });

        runner = Runner.create();
        
        const inputHandler = (e) => {
            const rect = render.canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            targetX = (clientX - rect.left) * (width / rect.width);
        };

        render.canvas.addEventListener('mousemove', inputHandler);
        render.canvas.addEventListener('touchmove', inputHandler, {passive: false});

        Events.on(render, 'afterRender', () => { drawHand(); checkLoseCondition(); updateTrayControl(); });
    }

    function setupLevel() {
        Composite.clear(engine.world);
        items = []; isGameOver = false;
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('countdown').style.display = 'none';
        document.getElementById('level-display').innerText = `LEVEL ${currentLevelIdx + 1}`;
        
        // VASSOIO: Leggero per reagire ai pesi (+15% dimensione)
        tray = Bodies.rectangle(width / 2, height - 250, 410, 25, { 
            density: 0.002, friction: 0.4, restitution: 0.1,
            render: { fillStyle: '#bdc3c7' }
        });

        // Perno fisico
        const pivot = Constraint.create({
            pointA: { x: width / 2, y: height - 250 },
            bodyB: tray,
            stiffness: 1, length: 0,
            render: { visible: false }
        });

        Composite.add(engine.world, [tray, pivot]);
        Render.run(render);
        Runner.run(runner, engine);
        spawnedCount = 0;
        startSpawning();
    }

    function updateTrayControl() {
        if (isGameOver || !tray) return;
        // Calcoliamo l'inclinazione desiderata basata sul mouse
        const mouseAngle = (targetX - width / 2) / (width / 2) * 1.3;
        // Applichiamo una forza di bilanciamento: più sei lontano dall'angolo del mouse, più forza ricevi
        const torque = (mouseAngle - tray.angle) * 0.2;
        Body.setAngularVelocity(tray, tray.angularVelocity + torque);

        // Limite fisico 140 gradi (circa 2.4 rad totali, 1.2 per lato)
        if (Math.abs(tray.angle) > 1.2) {
            Body.setAngle(tray, 1.2 * Math.sign(tray.angle));
            Body.setAngularVelocity(tray, 0);
        }
    }

    function spawnItem() {
        const startX = (width / 2) + (Math.random() * 340 - 170); 
        const type = Math.floor(Math.random() * 6);
        let item;
        const props = { friction: 0.3, restitution: 0.05, density: 0.01 }; // Densità alta per pesare molto

        switch(type) {
            case 0: // Calice Vino (Alto e instabile)
                item = Body.create({ parts: [
                    Bodies.trapezoid(startX, -100, 58, 52, 0.5, { render: { fillStyle: '#900020' }}),
                    Bodies.rectangle(startX, -65, 8, 40, { render: { fillStyle: '#fff' }}),
                    Bodies.rectangle(startX, -45, 45, 8, { render: { fillStyle: '#fff' }})
                ], ...props });
                break;
            case 1: // Boccale Birra (Molto pesante)
                item = Body.create({ parts: [
                    Bodies.rectangle(startX, -50, 65, 85, { chamfer: 5, render: { fillStyle: '#f28e1c' }}),
                    Bodies.rectangle(startX + 35, -50, 18, 50, { chamfer: 10, render: { fillStyle: '#eee' }})
                ], ...props, density: 0.015 });
                break;
            case 2: // Gin Lemon (Bicchiere largo)
                item = Bodies.rectangle(startX, -50, 58, 75, { ...props, render: { fillStyle: '#ffff00' }});
                break;
            case 3: // Bottiglietta Acqua (Leggera ma alta)
                item = Body.create({ parts: [
                    Bodies.rectangle(startX, -50, 35, 80, { render: { fillStyle: '#3498db' }}),
                    Bodies.rectangle(startX, -95, 20, 20, { render: { fillStyle: '#2980b9' }})
                ], ...props, density: 0.008 });
                break;
            case 4: // Bottiglia Birra (Alta e pesante)
                item = Body.create({ parts: [
                    Bodies.rectangle(startX, -50, 40, 95, { render: { fillStyle: '#3d2b1f' }}),
                    Bodies.rectangle(startX, -110, 15, 45, { render: { fillStyle: '#3d2b1f' }})
                ], ...props, density: 0.012 });
                break;
            case 5: // Chupito (Piccolo ma instabile se si muove veloce)
                item = Bodies.rectangle(startX, -50, 30, 45, { ...props, render: { fillStyle: '#e74c3c' }});
                break;
        }
        items.push(item);
        Composite.add(engine.world, item);
    }

    function drawHand() {
        const ctx = render.context;
        ctx.beginPath();
        ctx.moveTo(width / 2, height); 
        ctx.lineTo(tray.position.x, tray.position.y); 
        ctx.lineWidth = 50; ctx.strokeStyle = '#e0ac69'; ctx.lineCap = 'round'; ctx.stroke();
    }

    function startSpawning() {
        let interval = setInterval(() => {
            if (isGameOver || spawnedCount >= LEVELS[currentLevelIdx]) { 
                clearInterval(interval); 
                if(!isGameOver) startWinCountdown(); 
                return; 
            }
            spawnItem(); spawnedCount++;
            document.getElementById('items-display').innerText = `Items: ${spawnedCount}/${LEVELS[currentLevelIdx]}`;
        }, 2500);
    }

    function startWinCountdown() {
        let sec = 8;
        const el = document.getElementById('countdown');
        el.style.display = 'block';
        el.innerText = sec;
        let timer = setInterval(() => {
            if (isGameOver) { clearInterval(timer); return; }
            sec--;
            el.innerText = sec;
            if (sec <= 0) { 
                clearInterval(timer); 
                if(currentLevelIdx < LEVELS.length - 1) {
                    currentLevelIdx++; setupLevel(); 
                } else { alert("BAR MASTER!"); resetGame(); }
            }
        }, 1000);
    }

    function checkLoseCondition() {
        if (isGameOver) return;
        items.forEach(item => { if (item.position.y > height + 100) gameOver(); });
    }

    function gameOver() { isGameOver = true; document.getElementById('game-over-screen').style.display = 'flex'; }
    function startGame() { document.getElementById('start-screen').style.display = 'none'; init(); setupLevel(); }
    function resetGame() { document.getElementById('game-over-screen').style.display = 'none'; document.getElementById('start-screen').style.display = 'flex'; currentLevelIdx = 0; }
</script>
</body>
</html>
