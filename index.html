<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Bar Bahlance v81 debug</title>
  <style>
    :root{--bg:#0f1115;--panel:rgba(20,24,36,.92);--stroke:rgba(255,255,255,.12);--text:#e8e8e8;--muted:#aeb6c7;}
    html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #stage{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden;}
    canvas{display:block;touch-action:none;user-select:none;-webkit-user-select:none;border-radius:18px;background:#121625;}
    #hud{position:fixed;left:10px;right:10px;top:10px;display:flex;justify-content:space-between;gap:10px;z-index:5;pointer-events:none;}
    .pill{pointer-events:none;background:var(--panel);border:1px solid var(--stroke);border-radius:999px;padding:8px 12px;font-size:13px;backdrop-filter:blur(8px);display:flex;gap:10px;align-items:center;white-space:nowrap;}
    #debug{
      position:fixed;left:10px;right:10px;bottom:10px;z-index:9999;
      background:rgba(0,0,0,.65);border:1px solid rgba(255,255,255,.15);border-radius:12px;
      padding:10px;font-size:12px;line-height:1.35;white-space:pre-wrap;max-height:34vh;overflow:auto;
    }
    #debug b{color:#fff}
  </style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>

  <div id="hud">
    <div class="pill"><span>v81</span><span style="opacity:.6">â€¢</span><span id="status">boot</span></div>
    <div class="pill"><span id="counts">bodies: -</span></div>
  </div>

  <div id="debug"><b>DEBUG</b>\n</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
  (() => {
    const dbg = document.getElementById('debug');
    const statusEl = document.getElementById('status');
    const countsEl = document.getElementById('counts');
    const log = (m)=>{ dbg.textContent += m + "\n"; };

    window.addEventListener('error', (e)=>log("JS ERROR: " + (e.message || e.error || "unknown")));
    window.addEventListener('unhandledrejection', (e)=>log("REJECTION: " + (e.reason?.message || e.reason)));

    log("Matter loaded? " + (!!window.Matter));
    if(!window.Matter){
      statusEl.textContent = "Matter FAIL";
      log("STOP: matter.js non caricato");
      return;
    }

    const { Engine, World, Bodies, Body, Composite, Constraint } = Matter;

    // Canvas fit 2:3
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const WORLD_W=900, WORLD_H=1350;
    let cw=0,ch=0,dpr=1;

    function resize(){
      const w = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
      const h = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const targetH = Math.min(h, w*(3/2));
      const targetW = targetH*(2/3);
      cw = Math.floor(targetW);
      ch = Math.floor(targetH);
      canvas.style.width = cw+"px";
      canvas.style.height = ch+"px";
      canvas.width = Math.floor(cw*dpr);
      canvas.height = Math.floor(ch*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      log(`resize: css=${cw}x${ch} dpr=${dpr} backing=${canvas.width}x${canvas.height}`);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    function worldToScreen(){
      const s = Math.min(cw/WORLD_W, ch/WORLD_H);
      const ox = (cw - WORLD_W*s)/2;
      const oy = (ch - WORLD_H*s)/2;
      return {s,ox,oy};
    }
    function w2s(x,y){
      const {s,ox,oy}=worldToScreen();
      return {x:ox + x*s, y:oy + y*s, s};
    }

    // Physics minimal (tray + pivot only)
    const engine = Engine.create({ enableSleeping:true });
    engine.gravity.y = 1.0;
    engine.positionIterations = 12;
    engine.velocityIterations = 10;

    const world = engine.world;

    // walls + floor
    World.add(world, [
      Bodies.rectangle(-110, WORLD_H/2, 220, WORLD_H+1000, {isStatic:true}),
      Bodies.rectangle(WORLD_W+110, WORLD_H/2, 220, WORLD_H+1000, {isStatic:true}),
      Bodies.rectangle(WORLD_W/2, WORLD_H+90, WORLD_W+1200, 180, {isStatic:true}),
    ]);

    const wrist = { x: WORLD_W*0.5, y: WORLD_H*0.68 };
    const trayHome = { x: wrist.x, y: wrist.y - 115 };

    const tray = Bodies.rectangle(trayHome.x, trayHome.y, 640, 36, { chamfer:{radius:14}, friction:1.2, label:"tray" });
    World.add(world, tray);

    const pivot = Constraint.create({
      pointA: { x: wrist.x, y: wrist.y - 80 },
      bodyB: tray,
      length: 0,
      stiffness: 0.38,
      damping: 0.12
    });
    World.add(world, pivot);

    // simple drag control
    let targetAngle=0, dragging=false, lastX=0;
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function getNormX(e){
      const rect=canvas.getBoundingClientRect();
      const cx=(e.touches&&e.touches[0])?e.touches[0].clientX:e.clientX;
      return (cx-rect.left)/rect.width;
    }
    function down(e){ dragging=true; lastX=getNormX(e); }
    function move(e){
      if(!dragging) return;
      const x=getNormX(e); const dx=x-lastX; lastX=x;
      targetAngle = clamp(targetAngle + dx*2.6, -0.62, +0.62);
    }
    function up(){ dragging=false; }
    canvas.addEventListener('pointerdown', (e)=>{ canvas.setPointerCapture(e.pointerId); down(e); }, {passive:true});
    canvas.addEventListener('pointermove', move, {passive:true});
    canvas.addEventListener('pointerup', up, {passive:true});
    canvas.addEventListener('pointercancel', up, {passive:true});
    canvas.addEventListener('touchstart', down, {passive:true});
    canvas.addEventListener('touchmove', move, {passive:true});
    canvas.addEventListener('touchend', up, {passive:true});

    // loop
    let last=performance.now(), ticks=0;
    statusEl.textContent = "running";

    function drawBG(){
      const {s,ox,oy}=worldToScreen();
      ctx.save();
      ctx.translate(ox,oy);
      ctx.fillStyle="#121625";
      ctx.fillRect(0,0, WORLD_W*s, WORLD_H*s);
      ctx.restore();
    }

    function drawMarkers(){
      // wrist cross (red)
      const p = w2s(wrist.x, wrist.y);
      ctx.save();
      ctx.strokeStyle="#ff4444";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(p.x-10, p.y); ctx.lineTo(p.x+10, p.y);
      ctx.moveTo(p.x, p.y-10); ctx.lineTo(p.x, p.y+10);
      ctx.stroke();
      ctx.restore();

      // tray rect marker (yellow, based on body position/angle)
      const {s,ox,oy}=worldToScreen();
      ctx.save();
      ctx.translate(ox,oy);
      ctx.scale(s,s);
      ctx.translate(tray.position.x, tray.position.y);
      ctx.rotate(tray.angle);
      ctx.strokeStyle="#ffd45c";
      ctx.lineWidth=4;
      ctx.strokeRect(-320, -18, 640, 36);
      ctx.restore();
    }

    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000); last=now; ticks++;

      // PD-ish torque
      const Kp=0.030, Kd=0.020;
      const torque = (targetAngle - tray.angle)*Kp - tray.angularVelocity*Kd;
      Body.applyTorque(tray, torque);

      Engine.update(engine, dt*1000);

      drawBG();
      drawMarkers();

      const bodies = Composite.allBodies(world);
      countsEl.textContent = "bodies: " + bodies.length;

      if(ticks % 30 === 0){
        log(`tick=${ticks} trayPos=(${tray.position.x.toFixed(1)},${tray.position.y.toFixed(1)}) trayAngle=${tray.angle.toFixed(3)}`);
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>