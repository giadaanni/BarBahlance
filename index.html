<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BarBalance</title>
  <style>
    :root { --bg:#0f1115; --panel:#141824; --text:#e8e8e8; --muted:#aeb6c7; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; height:100%;}
    /* Full-viewport stage; canvas keeps 2:3 inside it */
    #stage{position:fixed; inset:0; display:grid; place-items:center; overflow:hidden;}
    canvas{display:block; touch-action:none; -webkit-user-select:none; user-select:none; border-radius:18px; background: #121625;}
    /* Overlay HUD (doesn't affect layout height => avoids scroll) */
    #hud{
      position:fixed; left: max(10px, env(safe-area-inset-left));
      right: max(10px, env(safe-area-inset-right));
      top: max(10px, env(safe-area-inset-top));
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px; padding:8px 12px; font-size:13px;
      display:flex; gap:10px; align-items:center; white-space:nowrap;
      backdrop-filter: blur(8px);
    }
    button{
      pointer-events:auto;
      border:0; border-radius:999px; padding:8px 12px;
      background:#2b3350; color:#fff; font-weight:700;
    }
    button:active{transform:scale(.99)}
    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:max(12px, env(safe-area-inset-bottom));
      background:rgba(20,24,36,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:10px 12px; font-size:13px;
      color:var(--muted);
      pointer-events:none;
      max-width:min(520px, calc(100vw - 24px));
      text-align:center;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>
  </div>

  <div id="hud">
    <div class="pill" id="leftPill">
      <span id="score">Score: 0</span>
      <span style="opacity:.6">•</span>
      <span id="items">Items: 0</span>
    </div>
    <div class="pill">
      <span id="state">OK</span>
      <button id="restart">Restart</button>
    </div>
  </div>

  <div id="hint">Trascina a sinistra/destra per ruotare il polso e bilanciare il vassoio.</div>

  <!-- Matter.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
  (() => {
    const {
      Engine, World, Bodies, Body, Composite
    } = Matter;

    // ---------- Canvas sizing (2:3 fits entire viewport on load) ----------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function getViewport() {
      // Prefer dynamic viewport units when available (iOS Safari)
      const h = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
      const w = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
      return { w, h };
    }

    const RATIO_W = 2, RATIO_H = 3; // 2:3 portrait
    let vw = 0, vh = 0, cw = 0, ch = 0, dpr = 1;

    function resizeCanvas() {
      ({ w: vw, h: vh } = getViewport());
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      // Fit 2:3 inside viewport
      const targetH = Math.min(vh, vw * (RATIO_H / RATIO_W));
      const targetW = targetH * (RATIO_W / RATIO_H);

      cw = Math.floor(targetW);
      ch = Math.floor(targetH);

      canvas.style.width = cw + "px";
      canvas.style.height = ch + "px";
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', resizeCanvas, { passive: true });
    resizeCanvas();

    // ---------- HUD ----------
    const scoreEl = document.getElementById('score');
    const itemsEl = document.getElementById('items');
    const stateEl = document.getElementById('state');
    const restartBtn = document.getElementById('restart');

    function setState(s) { stateEl.textContent = s; }

    // ---------- Physics world ----------
    const engine = Engine.create();
    engine.gravity.y = 1.0; // default-like
    const world = engine.world;

    // Scale world to canvas: use "pixels" as world units.
    // Keep room for arm and spawn.
    const WORLD_W = 900;
    const WORLD_H = 1350; // exactly 2:3 base

    // Map world->screen (scale to current cw/ch)
    function worldToScreenScale() {
      return Math.min(cw / WORLD_W, ch / WORLD_H);
    }
    function worldToScreen(x, y) {
      const s = worldToScreenScale();
      const ox = (cw - WORLD_W * s) / 2;
      const oy = (ch - WORLD_H * s) / 2;
      return { x: ox + x * s, y: oy + y * s, s };
    }

    // Static boundaries (slightly outside)
    const wallThickness = 120;
    const walls = [
      Bodies.rectangle(WORLD_W/2, WORLD_H + wallThickness/2, WORLD_W + 400, wallThickness, { isStatic:true }),
      Bodies.rectangle(-wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 400, { isStatic:true }),
      Bodies.rectangle(WORLD_W + wallThickness/2, WORLD_H/2, wallThickness, WORLD_H + 400, { isStatic:true })
    ];
    World.add(world, walls);

    // Tray + wrist pivot
    const wrist = { x: WORLD_W * 0.5, y: WORLD_H * 0.64 };

    const tray = Bodies.rectangle(wrist.x, wrist.y - 110, 640, 34, {
      restitution: 0.05,
      friction: 0.9,
      frictionStatic: 1.0,
      density: 0.004,
      label: "tray"
    });

    // Add a small "lip" as separate static-ish bodies attached by keeping same angle/pos in render only.
    // For physics simplicity: add two thin rails on top to help keep items in.
    const leftRail = Bodies.rectangle(tray.position.x - 320, tray.position.y - 10, 20, 26, { isStatic:true, label:"rail" });
    const rightRail = Bodies.rectangle(tray.position.x + 320, tray.position.y - 10, 20, 26, { isStatic:true, label:"rail" });

    World.add(world, [tray, leftRail, rightRail]);

    // Keep tray anchored near wrist (no translation drift), allow rotation.
    function lockTrayPosition() {
      Body.setPosition(tray, { x: wrist.x, y: wrist.y - 110 });
      Body.setVelocity(tray, { x: 0, y: 0 });
      // rails follow tray
      const a = tray.angle;
      const cos = Math.cos(a), sin = Math.sin(a);
      const offsets = [
        { body:leftRail, dx:-320, dy:-10 },
        { body:rightRail, dx:+320, dy:-10 }
      ];
      for (const o of offsets) {
        const x = tray.position.x + o.dx * cos - o.dy * sin;
        const y = tray.position.y + o.dx * sin + o.dy * cos;
        Body.setPosition(o.body, { x, y });
        Body.setAngle(o.body, a);
        Body.setVelocity(o.body, { x: 0, y: 0 });
      }
    }

    // ---------- Control (drag-only) ----------
    let targetAngle = 0;         // desired tray angle
    const MAX_ANGLE = 0.45;      // ~25.8°
    const SENS = 1.9;            // drag sensitivity

    let dragging = false;
    let lastX = 0;

    function getPointerX(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      return (clientX - rect.left) / rect.width; // 0..1
    }

    function onDown(e) {
      dragging = true;
      lastX = getPointerX(e);
    }
    function onMove(e) {
      if (!dragging) return;
      const x = getPointerX(e);
      const dx = x - lastX;
      lastX = x;
      targetAngle = clamp(targetAngle + dx * SENS, -MAX_ANGLE, +MAX_ANGLE);
    }
    function onUp() { dragging = false; }

    canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture(e.pointerId); onDown(e); }, { passive:true });
    canvas.addEventListener('pointermove', (e) => onMove(e), { passive:true });
    canvas.addEventListener('pointerup', onUp, { passive:true });
    canvas.addEventListener('pointercancel', onUp, { passive:true });

    // iOS sometimes prefers touch events; keep both
    canvas.addEventListener('touchstart', onDown, { passive:true });
    canvas.addEventListener('touchmove', onMove, { passive:true });
    canvas.addEventListener('touchend', onUp, { passive:true });

    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    // PD controller for tray rotation
    function controlTray(dt) {
      const kp = 20.0, kd = 5.2;
      const err = targetAngle - tray.angle;
      const torqueLike = kp * err - kd * tray.angularVelocity;
      // approximate: directly set angular velocity increment
      Body.setAngularVelocity(tray, tray.angularVelocity + torqueLike * dt);
      // soft clamp
      if (Math.abs(tray.angle) > MAX_ANGLE * 1.05) {
        Body.setAngle(tray, clamp(tray.angle, -MAX_ANGLE, +MAX_ANGLE));
        Body.setAngularVelocity(tray, tray.angularVelocity * 0.2);
      }
    }

    // ---------- Items + fake liquid ----------
    let alive = true;
    let score = 0;
    let t = 0;
    let nextSpawn = 1.2;
    let spawnEvery = 1.2;

    function spawn(kind) {
      const x = WORLD_W * (0.35 + Math.random()*0.30);
      const y = WORLD_H * 0.10;

      if (kind === "tumbler") {
        const b = Bodies.rectangle(x, y, 44, 62, {
          restitution: 0.02, friction: 0.8, density: 0.0028, label:"tumbler"
        });
        b.plugin = { liquid: { fill: 0.78, slosh: 0, color:"#6bdcff" } };
        World.add(world, b);
        return;
      }

      if (kind === "wine") {
        // Simple convex polygon approximating a goblet (stable? not really)
        const verts = [
          {x:-10,y:-60},{x:10,y:-60},{x:26,y:-32},{x:18,y:0},
          {x:10,y:8},{x:10,y:44},{x:18,y:52},{x:18,y:62},{x:-18,y:62},{x:-18,y:52},{x:-10,y:44},{x:-10,y:8},{x:-18,y:0},{x:-26,y:-32}
        ];
        const b = Bodies.fromVertices(x, y, [verts], {
          restitution: 0.03, friction: 0.55, density: 0.0022, label:"wine"
        }, true);
        b.plugin = { liquid: { fill: 0.62, slosh: 0, color:"#ff7a59" } };
        World.add(world, b);
        return;
      }

      if (kind === "bottle") {
        const b = Bodies.rectangle(x, y, 34, 98, {
          restitution: 0.02, friction: 0.6, density: 0.0034, label:"bottle"
        });
        // no liquid rendering inside bottle (optional later)
        World.add(world, b);
        return;
      }
    }

    function maybeSpawn() {
      if (t < nextSpawn) return;

      // Difficulty ramps
      const difficulty = Math.min(1, t / 55);
      spawnEvery = Math.max(0.55, spawnEvery * (0.988 - 0.004*difficulty));
      nextSpawn = t + spawnEvery;

      // Weighted choice
      const r = Math.random();
      if (r < 0.45) spawn("tumbler");
      else if (r < 0.78) spawn("wine");
      else spawn("bottle");
    }

    // Fake spill: if slosh angle too high => reduce fill and spawn droplets
    const droplets = [];
    function addDroplet(x,y,vx,vy,color){
      droplets.push({x,y,vx,vy,color,life:1.2});
    }

    function updateLiquids(dt) {
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (!b.plugin || !b.plugin.liquid) continue;
        const liq = b.plugin.liquid;

        // Apparent acceleration proxy: use angular velocity + tilt
        // (not physically exact; chosen for good feel)
        const targetSlosh = clamp((-b.angularVelocity * 0.9) + (tray.angle * 0.7), -0.8, 0.8);
        liq.slosh += (targetSlosh - liq.slosh) * (1 - Math.exp(-8 * dt));

        // Spill threshold depends on fill
        const spillThresh = 0.55 - (liq.fill * 0.18);
        if (Math.abs(liq.slosh) > spillThresh && liq.fill > 0.08) {
          const spillRate = (Math.abs(liq.slosh) - spillThresh) * 0.18;
          liq.fill = Math.max(0, liq.fill - spillRate * dt);

          // spawn a few droplets for comedy (screen-space later)
          if (Math.random() < 0.25) {
            // approximate droplet origin at top of body
            const p = b.position;
            addDroplet(p.x + (Math.random()*16-8), p.y - 40, (Math.random()*40-20), 40 + Math.random()*60, liq.color);
          }
        }
      }

      // droplets physics-lite
      for (let i=droplets.length-1;i>=0;i--){
        const d = droplets[i];
        d.vy += 220 * dt;
        d.x += d.vx * dt;
        d.y += d.vy * dt;
        d.life -= dt;
        if (d.life <= 0 || d.y > WORLD_H + 80) droplets.splice(i,1);
      }
    }

    // Lose if any item falls far below tray area
    function checkLose() {
      if (!alive) return;
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label === "tray" || b.label === "rail" || b.isStatic) continue;
        if (b.position.y > WORLD_H * 1.05) {
          alive = false;
          setState("GAME OVER");
          return;
        }
      }
    }

    function reset() {
      // Remove non-static bodies except tray/rails/walls
      const bodies = Composite.allBodies(world);
      for (const b of bodies) {
        if (b.label === "tray" || b.label === "rail" || b.isStatic) continue;
        World.remove(world, b);
      }
      droplets.length = 0;

      alive = true;
      score = 0;
      t = 0;
      nextSpawn = 1.2;
      spawnEvery = 1.2;
      targetAngle = 0;
      Body.setAngle(tray, 0);
      Body.setAngularVelocity(tray, 0);
      setState("OK");
    }

    restartBtn.addEventListener('click', reset);

    // ---------- Flat vector rendering ----------
    function drawBackground() {
      // subtle grid
      ctx.save();
      const {x:ox,y:oy,s} = worldToScreen(0,0);
      ctx.translate(ox, oy);

      ctx.fillStyle = "#121625";
      ctx.fillRect(0,0, WORLD_W*s, WORLD_H*s);

      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = "#9aa3b2";
      ctx.lineWidth = 1;
      const step = 90*s;
      for (let x=0; x<=WORLD_W*s; x+=step) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_H*s); ctx.stroke(); }
      for (let y=0; y<=WORLD_H*s; y+=step) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W*s,y); ctx.stroke(); }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function pathVertices(verts) {
      ctx.beginPath();
      ctx.moveTo(verts[0].x, verts[0].y);
      for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
      ctx.closePath();
    }

    function drawBody(b) {
      const {x:ox,y:oy,s} = worldToScreen(0,0);
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      if (b.label === "tray") {
        // tray plank
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);

        // shadow
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        roundRect(ctx, -330, -10, 660, 38, 18);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#3b4258";
        ctx.beginPath();
        roundRect(ctx, -320, -18, 640, 34, 16);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        roundRect(ctx, -312, -14, 624, 26, 14);
        ctx.stroke();

        ctx.restore();
        ctx.restore();
        return;
      }

      if (b.label === "rail") {
        // invisible physics; skip render
        ctx.restore();
        return;
      }

      // Choose style per label
      let fill = "#dfe6ff";
      let stroke = "rgba(255,255,255,.18)";
      let lw = 2;

      if (b.label === "tumbler") fill = "#cfd8ff";
      if (b.label === "wine") fill = "#d8e2ff";
      if (b.label === "bottle") fill = "#7de0b8";

      // Body shape
      const verts = b.vertices;
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lw;

      pathVertices(verts);
      ctx.fill();
      ctx.stroke();

      // Liquid (fake) for glasses
      if (b.plugin && b.plugin.liquid) {
        drawLiquidInBody(b, ox, oy, s);
      }

      ctx.restore();
    }

    function drawLiquidInBody(b, ox, oy, s) {
      const liq = b.plugin.liquid;

      // Clip to body shape
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      const verts = b.vertices;
      pathVertices(verts);
      ctx.clip();

      // Approximate "container bounds" in local coords:
      // Use body AABB + fill ratio to choose liquid height
      const bounds = b.bounds;
      const h = (bounds.max.y - bounds.min.y);
      const w = (bounds.max.x - bounds.min.x);

      const levelY = bounds.max.y - h * liq.fill;
      const tilt = liq.slosh;

      // Liquid plane: y = levelY + tilt*(x - centerX)
      const cx = (bounds.min.x + bounds.max.x) * 0.5;

      ctx.fillStyle = liq.color;
      ctx.globalAlpha = 0.9;

      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 80, bounds.max.y + 80);
      ctx.lineTo(bounds.max.x + 80, bounds.max.y + 80);

      const y2 = levelY + tilt * (bounds.max.x - cx) * 0.9;
      const y1 = levelY + tilt * (bounds.min.x - cx) * 0.9;
      ctx.lineTo(bounds.max.x + 80, y2);
      ctx.lineTo(bounds.min.x - 80, y1);
      ctx.closePath();
      ctx.fill();

      // subtle highlight line
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bounds.min.x - 40, y1);
      ctx.lineTo(bounds.max.x + 40, y2);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawArmAndHand() {
      const {x:ox,y:oy,s} = worldToScreen(0,0);
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      // arm
      ctx.save();
      ctx.translate(wrist.x, wrist.y + 220);
      ctx.rotate(-0.15);
      ctx.fillStyle = "#b28b68";
      roundRect(ctx, -120, -40, 240, 520, 90);
      ctx.fill();
      ctx.restore();

      // hand base (palm) near wrist
      ctx.save();
      // Align hand with tray angle but slightly damped (visual polish)
      const a = tray.angle * 0.95;
      ctx.translate(wrist.x, wrist.y + 40);
      ctx.rotate(a);
      ctx.fillStyle = "#caa07a";
      roundRect(ctx, -160, -46, 320, 92, 46);
      ctx.fill();

      // simple fingers
      ctx.fillStyle = "#d3ac86";
      for (let i=0;i<4;i++){
        roundRect(ctx, -140 + i*70, -92, 56, 54, 22);
        ctx.fill();
      }
      ctx.restore();

      // wrist pivot dot
      ctx.fillStyle = "rgba(255,255,255,.16)";
      ctx.beginPath();
      ctx.arc(wrist.x, wrist.y, 10, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawDroplets() {
      const {x:ox,y:oy,s} = worldToScreen(0,0);
      ctx.save();
      ctx.translate(ox, oy);
      ctx.scale(s, s);

      for (const d of droplets) {
        ctx.globalAlpha = Math.max(0, Math.min(1, d.life));
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(d.x, d.y, 4, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Main loop ----------
    let last = performance.now();
    function tick(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (alive) {
        t += dt;
        maybeSpawn();
        score += dt * (2 + 0.35 * countItems());
      }

      // Control + step physics
      controlTray(dt);
      Engine.update(engine, dt * 1000);
      lockTrayPosition();
      updateLiquids(dt);
      checkLose();

      // Render
      drawBackground();
      drawArmAndHand();

      // Draw bodies (tray last for layering? Actually tray under items feels better.)
      const bodies = Composite.allBodies(world);

      // Draw tray first, then items
      const trayBody = bodies.find(b => b.label === "tray");
      if (trayBody) drawBody(trayBody);

      for (const b of bodies) {
        if (b.label === "tray" || b.label === "rail" || b.isStatic) continue;
        drawBody(b);
      }
      drawDroplets();

      // HUD
      scoreEl.textContent = `Score: ${Math.floor(score)}`;
      itemsEl.textContent = `Items: ${countItems()}`;

      requestAnimationFrame(tick);
    }

    function countItems() {
      const bodies = Composite.allBodies(world);
      let n = 0;
      for (const b of bodies) {
        if (b.label === "tray" || b.label === "rail" || b.isStatic) continue;
        n++;
      }
      return n;
    }

    reset();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
