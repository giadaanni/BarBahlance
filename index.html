<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bar Bahlance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
        }

        #game-container {
            position: relative;
            width: 100vh;
            max-width: 100%;
            aspect-ratio: 2/3;
            background-color: #4a3b59;
            overflow: hidden;
            border: 4px solid #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        /* MODIFICA: Percorso aggiornato a ASSET e nome file PNG */
        #start-screen {
            background: url('./ASSET/BarBahlance_mainScreen.png') no-repeat center center;
            background-size: cover;
            pointer-events: auto;
            cursor: pointer;
        }

        .blink-text {
            margin-top: 60%;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            font-size: 20px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        #hud {
            justify-content: flex-start;
            padding-top: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 14px;
        }

        #countdown {
            font-size: 40px;
            color: yellow;
            display: none;
        }

        #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            display: none;
            pointer-events: auto;
        }

        .btn {
            background: #ffcc00;
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        .btn:hover { background: #ff9900; }

    </style>
</head>
<body>

<div id="game-container">
    <div id="start-screen" class="ui-layer" onclick="startGame()">
        <div class="blink-text">TAP TO START</div>
    </div>

    <div id="hud" class="ui-layer">
        <div id="level-display">LEVEL 1</div>
        <div id="items-display">Items: 0/3</div>
        <div id="countdown"></div>
    </div>

    <div id="game-over-screen" class="ui-layer">
        <h1 style="color: red; text-shadow: 3px 3px 0 #000;">CRASH!</h1>
        <p>You dropped a drink!</p>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>
</div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body;

    const LEVELS = [3, 5, 7, 10, 12];
    
    let engine, render, runner;
    let tray;
    let items = [];
    let currentLevelIdx = 0;
    let itemsToSpawn = 0;
    let spawnedCount = 0;
    let isGameOver = false;
    let countdownTimer = null;
    let spawnInterval = null;
    
    const width = 600;
    const height = 900;

    function init() {
        engine = Engine.create();
        const container = document.getElementById('game-container');
        const oldCanvas = container.querySelector('canvas');
        if(oldCanvas) oldCanvas.remove();

        render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false, 
                background: 'transparent'
            }
        });

        runner = Runner.create();
        
        render.canvas.addEventListener('mousemove', handleInput);
        render.canvas.addEventListener('touchmove', handleInput, {passive: false});

        Events.on(render, 'afterRender', function() {
            drawHand();
            checkLoseCondition();
        });
    }

    function setupLevel() {
        Composite.clear(engine.world);
        Engine.clear(engine);
        items = [];
        isGameOver = false;
        
        document.getElementById('level-display').innerText = `LEVEL ${currentLevelIdx + 1}`;
        document.getElementById('items-display').innerText = `Next: ${LEVELS[currentLevelIdx]}`;
        document.getElementById('countdown').style.display = 'none';
        
        tray = Bodies.rectangle(width / 2, height - 200, 350, 20, { 
            isStatic: true, 
            chamfer: { radius: 5 },
            render: { fillStyle: '#C0C0C0' },
            friction: 0.1, 
            frictionStatic: 0.1
        });

        Composite.add(engine.world, tray);

        Render.run(render);
        Runner.run(runner, engine);

        itemsToSpawn = LEVELS[currentLevelIdx];
        spawnedCount = 0;
        startSpawning();
    }

    function handleInput(e) {
        if (isGameOver) return;
        e.preventDefault();
        let clientX = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        const rect = render.canvas.getBoundingClientRect();
        const scaleX = width / rect.width;
        const x = (clientX - rect.left) * scaleX;

        const maxAngle = 60 * (Math.PI / 180); 
        const normalizedX = (x - width / 2) / (width / 2); 
        let targetAngle = Math.max(Math.min(normalizedX * maxAngle, maxAngle), -maxAngle);

        const currentAngle = tray.angle;
        const smoothFactor = 0.1; 
        const newAngle = currentAngle + (targetAngle - currentAngle) * smoothFactor;
        Body.setAngle(tray, newAngle);
    }

    function drawHand() {
        const ctx = render.context;
        const trayPos = tray.position;
        ctx.beginPath();
        ctx.moveTo(width / 2, height); 
        ctx.lineTo(trayPos.x, trayPos.y); 
        ctx.lineWidth = 40;
        ctx.strokeStyle = '#e0ac69'; 
        ctx.lineCap = 'round';
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(width / 2, height);
        ctx.lineTo(width/2, height - 100);
        ctx.lineWidth = 45;
        ctx.strokeStyle = '#fff';
        ctx.stroke();
    }

    function startSpawning() {
        spawnInterval = setInterval(() => {
            if (isGameOver) { clearInterval(spawnInterval); return; }
            if (spawnedCount >= itemsToSpawn) {
                clearInterval(spawnInterval);
                checkWinCondition(); 
                return;
            }
            spawnItem();
            spawnedCount++;
            document.getElementById('items-display').innerText = `Items: ${spawnedCount}/${itemsToSpawn}`;
        }, 2000);
    }

    function spawnItem() {
        const startX = (width / 2) + (Math.random() * 300 - 150); 
        const itemType = Math.floor(Math.random() * 5);
        let item;
        const commonProps = { friction: 0.09, frictionStatic: 0.09, restitution: 0.2, render: { strokeStyle: '#000', lineWidth: 2 } };

        switch(itemType) {
            case 0: // Boccale
                const mugBody = Bodies.rectangle(startX, -50, 50, 70, { render: { fillStyle: '#f28e1c' } });
                const mugHandle = Bodies.rectangle(startX + 30, -50, 15, 40, { render: { fillStyle: '#f28e1c' } });
                item = Body.create({ parts: [mugBody, mugHandle], density: 0.005, ...commonProps });
                break;
            case 1: // Bottiglia
                const botNeck = Bodies.rectangle(startX, -90, 15, 40, { render: { fillStyle: '#2e8b57' } });
                const botBody = Bodies.rectangle(startX, -50, 30, 60, { render: { fillStyle: '#2e8b57' } });
                item = Body.create({ parts: [botNeck, botBody], density: 0.004, ...commonProps });
                break;
            case 2: // Calice
                const cup = Bodies.polygon(startX, -70, 3, 25, { angle: Math.PI, render: { fillStyle: '#900020' } });
                const stem = Bodies.rectangle(startX, -45, 5, 25, { render: { fillStyle: '#fff' } });
                const base = Bodies.rectangle(startX, -30, 25, 5, { render: { fillStyle: '#fff' } });
                item = Body.create({ parts: [cup, stem, base], density: 0.003, ...commonProps });
                break;
            case 3: // Shot
                item = Bodies.rectangle(startX, -50, 25, 30, { render: { fillStyle: '#ADD8E6' }, density: 0.004, ...commonProps });
                break;
            case 4: // Drink
                item = Bodies.rectangle(startX, -50, 45, 50, { render: { fillStyle: '#ff69b4' }, density: 0.004, ...commonProps });
                break;
        }
        items.push(item);
        Composite.add(engine.world, item);
    }

    function checkLoseCondition() {
        if (isGameOver) return;
        items.forEach(item => { if (item.position.y > height + 50) gameOver(); });
    }

    function checkWinCondition() {
        let timeLeft = 8;
        const countEl = document.getElementById('countdown');
        countEl.style.display = 'block';
        countEl.innerText = timeLeft;
        countdownTimer = setInterval(() => {
            if (isGameOver) { clearInterval(countdownTimer); return; }
            timeLeft--;
            countEl.innerText = timeLeft;
            if (timeLeft <= 0) { clearInterval(countdownTimer); levelComplete(); }
        }, 1000);
    }

    function levelComplete() {
        if (currentLevelIdx < LEVELS.length - 1) {
            currentLevelIdx++;
            alert("LEVEL COMPLETE! Next: Level " + (currentLevelIdx + 1));
            setupLevel(); 
        } else {
            alert("WINNER!");
            currentLevelIdx = 0;
            document.getElementById('start-screen').style.display = 'flex';
        }
    }

    function gameOver() {
        isGameOver = true;
        clearInterval(spawnInterval);
        clearInterval(countdownTimer);
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        init();
        setupLevel();
    }

    function resetGame() {
        document.getElementById('game-over-screen').style.display = 'none';
        currentLevelIdx = 0; 
        setupLevel();
    }
</script>
</body>
</html>
